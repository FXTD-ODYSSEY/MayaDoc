<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../scripts/utils/adsk.redirect.js"></script>
      <title>MRenderUtil Class Reference</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_render_util.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>MRenderUtil Class Reference</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/files.html"><span>Files</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="#!/url=./cpp_ref/classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="#!/url=./cpp_ref/hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="#!/url=./cpp_ref/functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  
  <div class="headertitle">
<div class="title">MRenderUtil Class Reference<div class="ingroups"><a class="el" translate="no" href="#!/url=./cpp_ref/group___open_maya_render.html">OpenMayaRender - API module for rendering</a></div></div>  </div>
<div id="OverviewLinksDiv"><div id="dynsection-overview" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><img id="dynsection-overview-trigger" src="cpp_ref/closed.png" alt="+"> Related help topics: </div><div id="dynsection-overview-content" class="dyncontent" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2016-2/C-API-Changes-in-Maya-2016.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2016 &gt; C++ API Changes in Maya 2016</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/Autodesk-Maya-2015.html">What&#39;s New / What&#39;s Changed? &gt; Autodesk Maya 2015</a></li>
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/Autodesk-Maya-2014.html">What&#39;s New / What&#39;s Changed? &gt; Autodesk Maya 2014</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Writing-a-Software-Shading-Node/Evaluating-shading-nodes-outside.html">Writing a Software Shading Node &gt; Evaluating shading nodes outside of the rendering context</a></li>
<li class="overviewLink"><a href="#!/url=./developer/Viewport-2-0-API/Maya-Viewport-2-0-API-Guide/Advanced-Topics/Color-management-support-for.html">Viewport 2.0 API &gt; Maya Viewport 2.0 API Guide &gt; Advanced Topics &gt; Color management support for plug-in shaders in Viewport 2.0</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_render_util.html#pub-types">Public Types</a> &#124;
<a href="class_m_render_util.html#pub-static-methods">Static Public Member Functions</a>  </div></div><!--header-->
<div class="contents">

<p><code>#include &lt;MRenderUtil.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><p>Common API rendering functions. </p>
<p><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html" title="Common API rendering functions. ">MRenderUtil</a> is a class which provides static API methods to access Maya's rendering functionalities. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a04a6ed8afe0aa15ec3ab40df97a02251"><td class="memItemLeft" translate="no" align="right" valign="top">enum &#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251">MRenderState</a> { <br>
&#160;&#160;<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251a2ae5259a1e5c4202a18145d34473b7b6">kNotRendering</a>, 
<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251acc4d94cbd95f4ddf20b9d4c227fd201e">kBatchRender</a>, 
<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251a69aee1f9b7b6b2bfc771b00258d9d01e">kInteractiveRender</a>, 
<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251a507b3cef2cfa738dd3cc29852a262b00">kIprRender</a>, 
<br>
&#160;&#160;<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251ae833a6de784804e1d4f15c2fad018f6f">kHardwareRender</a>
<br>
 }<tr class="memdesc:a04a6ed8afe0aa15ec3ab40df97a02251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the current rendering state of Maya.  <a href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251">More...</a><br></td></tr>
<tr class="separator:a04a6ed8afe0aa15ec3ab40df97a02251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ab15600fa49838d1c2b4d4c3ba73c41da"><td class="memItemLeft" translate="no" align="right" valign="top">enum &#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41da">MRenderPass</a> { <br>
&#160;&#160;<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa8d857bf5569760ac7306382a558cb092">kAll</a>, 
<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa3ffb5a65daa385aafe521dca897a1c42">kColorOnly</a>, 
<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa059ab4a7af031ed9d02ecb004ae09ce1">kShadowOnly</a>, 
<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daabf3fd40258f099e6519ba09d6041b79f">kAmbientOnly</a>, 
<br>
&#160;&#160;<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa71c7c30537ed19af65653b3ffdd6ca2a">kDiffuseOnly</a>, 
<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa6bbfaadb24b835d76a23e720376782ab">kSpecularOnly</a>
<br>
 }<tr class="memdesc:ab15600fa49838d1c2b4d4c3ba73c41da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the current pass of Maya.  <a href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41da">More...</a><br></td></tr>
<tr class="separator:ab15600fa49838d1c2b4d4c3ba73c41da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a75ba1ad417f7867b4a064d690ceabba2"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251">MRenderState</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a75ba1ad417f7867b4a064d690ceabba2">mayaRenderState</a> ()</td></tr>
<tr class="memdesc:a75ba1ad417f7867b4a064d690ceabba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerated type specifying the current state of the Maya renderer.  <a href="class_m_render_util.html#a75ba1ad417f7867b4a064d690ceabba2">More...</a><br></td></tr>
<tr class="separator:a75ba1ad417f7867b4a064d690ceabba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228b2661ed753557a3b48a29321d3417"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a228b2661ed753557a3b48a29321d3417">raytrace</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;rayOrigin, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;rayDirection, const void *objectId, const void *raySampler, const short rayDepth, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;resultColor, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;resultTransparency, const bool isReflectedRays=true)</td></tr>
<tr class="memdesc:a228b2661ed753557a3b48a29321d3417"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility method provides functionality to raytrace from within a shader plug-in.  <a href="class_m_render_util.html#a228b2661ed753557a3b48a29321d3417">More...</a><br></td></tr>
<tr class="separator:a228b2661ed753557a3b48a29321d3417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4aa707b8b78542a961a5d9ba2e96f9"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#afe4aa707b8b78542a961a5d9ba2e96f9">raytrace</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;rayOrigins, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;rayDirections, const void *objectId, const void *raySampler, const short rayDepth, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;resultColors, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;resultTransparencies, const bool isReflectedRays=true)</td></tr>
<tr class="memdesc:afe4aa707b8b78542a961a5d9ba2e96f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility method provides functionality to raytrace from within a shader plug-in.  <a href="class_m_render_util.html#afe4aa707b8b78542a961a5d9ba2e96f9">More...</a><br></td></tr>
<tr class="separator:afe4aa707b8b78542a961a5d9ba2e96f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb868fb03dcccdb9fb6d18f7f93c834c"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#aeb868fb03dcccdb9fb6d18f7f93c834c">raytraceFirstGeometryIntersections</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;rayOrigins, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;rayDirections, const void *objectId, const void *raySampler, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;resultIntersections, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;resultIntersected)</td></tr>
<tr class="memdesc:aeb868fb03dcccdb9fb6d18f7f93c834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility method provides functionality to find the location of the first geometry intersected by a ray from within a shader plug-in.  <a href="class_m_render_util.html#aeb868fb03dcccdb9fb6d18f7f93c834c">More...</a><br></td></tr>
<tr class="separator:aeb868fb03dcccdb9fb6d18f7f93c834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9ba1907baa091db043c29581c963fe"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a6b9ba1907baa091db043c29581c963fe">sampleShadingNetwork</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> shadingNodeName, int numSamples, bool useShadowMaps, bool reuseMaps, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_matrix.html">MFloatMatrix</a> &amp;cameraMatrix, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_point_array.html">MFloatPointArray</a> *points, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> *uCoords, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> *vCoords, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> *normals, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_point_array.html">MFloatPointArray</a> *refPoints, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> *tangentUs, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> *tangentVs, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> *filterSizes, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;resultColors, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;resultTransparencies)</td></tr>
<tr class="memdesc:a6b9ba1907baa091db043c29581c963fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility method allows you to sample a shading node/shading engine.  <a href="class_m_render_util.html#a6b9ba1907baa091db043c29581c963fe">More...</a><br></td></tr>
<tr class="separator:a6b9ba1907baa091db043c29581c963fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93eb671899250f03b16ec74e7ce70ce9"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a93eb671899250f03b16ec74e7ce70ce9">generatingIprFile</a> ()</td></tr>
<tr class="memdesc:a93eb671899250f03b16ec74e7ce70ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an IPR file is being created.  <a href="class_m_render_util.html#a93eb671899250f03b16ec74e7ce70ce9">More...</a><br></td></tr>
<tr class="separator:a93eb671899250f03b16ec74e7ce70ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2909a1a35a376470df355e520cb81b4"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ae2909a1a35a376470df355e520cb81b4">relativeFileName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;absFileName, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ae2909a1a35a376470df355e520cb81b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract relative file name from the given (absolute) file name.  <a href="class_m_render_util.html#ae2909a1a35a376470df355e520cb81b4">More...</a><br></td></tr>
<tr class="separator:ae2909a1a35a376470df355e520cb81b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419f62773e2626b29666ca4dd2cf5370"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a419f62773e2626b29666ca4dd2cf5370">exactFileTextureName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;fileNode, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;texturePath, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a419f62773e2626b29666ca4dd2cf5370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to resolve the file texture name specified on a file texture node into an absolute path to an image file on disk.  <a href="class_m_render_util.html#a419f62773e2626b29666ca4dd2cf5370">More...</a><br></td></tr>
<tr class="separator:a419f62773e2626b29666ca4dd2cf5370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9b48654b87d16fe79b9e08c7b72c64"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a3e9b48654b87d16fe79b9e08c7b72c64">exactFileTextureName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;baseName, bool useFrameExt, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;currentFrameExt, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;exactName, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a3e9b48654b87d16fe79b9e08c7b72c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">obsolete, use the one with contextNodeFullName param  <a href="class_m_render_util.html#a3e9b48654b87d16fe79b9e08c7b72c64">More...</a><br></td></tr>
<tr class="separator:a3e9b48654b87d16fe79b9e08c7b72c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdc7ff71c27bf1e3e05220453da8225"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a4cdc7ff71c27bf1e3e05220453da8225">exactFileTextureName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;baseName, bool useFrameExt, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;currentFrameExt, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;contextNodeFullName, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;exactName, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a4cdc7ff71c27bf1e3e05220453da8225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to resolve the file name specified into an absolute path to a file on disk.  <a href="class_m_render_util.html#a4cdc7ff71c27bf1e3e05220453da8225">More...</a><br></td></tr>
<tr class="separator:a4cdc7ff71c27bf1e3e05220453da8225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8c405e8dbbe4776c5a6bdc64945337"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a8b8c405e8dbbe4776c5a6bdc64945337">exactFileTextureUvTileData</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;fileNode, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> &amp;tilePaths, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> &amp;tilePositions, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a8b8c405e8dbbe4776c5a6bdc64945337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to resolve all the paths to UV tiles for the given file texture node into absolute paths to image files on disk.  <a href="class_m_render_util.html#a8b8c405e8dbbe4776c5a6bdc64945337">More...</a><br></td></tr>
<tr class="separator:a8b8c405e8dbbe4776c5a6bdc64945337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159bc820f6f90b218d74b49444a649af"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a159bc820f6f90b218d74b49444a649af">convertPsdFile</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;fileNode, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;texturePath, const bool &amp;forExport=false, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a159bc820f6f90b218d74b49444a649af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="class_m_render_util.html#a159bc820f6f90b218d74b49444a649af">More...</a><br></td></tr>
<tr class="separator:a159bc820f6f90b218d74b49444a649af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedd58b582f49bb34904677dd52b5b43"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#acedd58b582f49bb34904677dd52b5b43">exactImagePlaneFileName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;imagePlaneNode, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;texturePath, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:acedd58b582f49bb34904677dd52b5b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to resolve the file texture name specified on an image plane node into an absolute path to an image file on disk.  <a href="class_m_render_util.html#acedd58b582f49bb34904677dd52b5b43">More...</a><br></td></tr>
<tr class="separator:acedd58b582f49bb34904677dd52b5b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606ecc4f9e73be82a731c67664e1645c"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a606ecc4f9e73be82a731c67664e1645c">exactFileTextureName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;fileNode, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a606ecc4f9e73be82a731c67664e1645c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to resolve the file texture name specified on a file texture node into an absolute path to an image file on disk.  <a href="class_m_render_util.html#a606ecc4f9e73be82a731c67664e1645c">More...</a><br></td></tr>
<tr class="separator:a606ecc4f9e73be82a731c67664e1645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3336c4390d5092c3d929ebdd38ead524"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a3336c4390d5092c3d929ebdd38ead524">exactFileTextureName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;baseName, bool useFrameExt, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;currentFrameExt, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a3336c4390d5092c3d929ebdd38ead524"><td class="mdescLeft">&#160;</td><td class="mdescRight">obsolete, use the one with contextNodeFullName param  <a href="class_m_render_util.html#a3336c4390d5092c3d929ebdd38ead524">More...</a><br></td></tr>
<tr class="separator:a3336c4390d5092c3d929ebdd38ead524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569c5e0877ab2e07a147b9fab137d4ce"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a569c5e0877ab2e07a147b9fab137d4ce">exactFileTextureName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;baseName, bool useFrameExt, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;currentFrameExt, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;contextNodeFullName, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a569c5e0877ab2e07a147b9fab137d4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to resolve the file name specified into an absolute path to a file on disk.  <a href="class_m_render_util.html#a569c5e0877ab2e07a147b9fab137d4ce">More...</a><br></td></tr>
<tr class="separator:a569c5e0877ab2e07a147b9fab137d4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1e7db93c17c4e8537a2db21f6d6b00"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a4c1e7db93c17c4e8537a2db21f6d6b00">convertPsdFile</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;fileNode, const bool &amp;forExport=false, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a4c1e7db93c17c4e8537a2db21f6d6b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="class_m_render_util.html#a4c1e7db93c17c4e8537a2db21f6d6b00">More...</a><br></td></tr>
<tr class="separator:a4c1e7db93c17c4e8537a2db21f6d6b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ba20f25e88ad324b66338533cef000"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab5ba20f25e88ad324b66338533cef000">exactImagePlaneFileName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;imagePlaneNode, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ab5ba20f25e88ad324b66338533cef000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to resolve the file texture name specified on an image plane node into an absolute path to an image file on disk.  <a href="class_m_render_util.html#ab5ba20f25e88ad324b66338533cef000">More...</a><br></td></tr>
<tr class="separator:ab5ba20f25e88ad324b66338533cef000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330ffaa4fa8fe2c3dc1e3ea826d3dad8"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a330ffaa4fa8fe2c3dc1e3ea826d3dad8">inCurrentRenderLayer</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;objectPath, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a330ffaa4fa8fe2c3dc1e3ea826d3dad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified path is in the current render layer.  <a href="class_m_render_util.html#a330ffaa4fa8fe2c3dc1e3ea826d3dad8">More...</a><br></td></tr>
<tr class="separator:a330ffaa4fa8fe2c3dc1e3ea826d3dad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe25fe2c0429e689f46d5aa734957d9"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41da">MRenderPass</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a1fe25fe2c0429e689f46d5aa734957d9">renderPass</a> (void)</td></tr>
<tr class="memdesc:a1fe25fe2c0429e689f46d5aa734957d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerated type specifying the current pass the Maya renderer is executing.  <a href="class_m_render_util.html#a1fe25fe2c0429e689f46d5aa734957d9">More...</a><br></td></tr>
<tr class="separator:a1fe25fe2c0429e689f46d5aa734957d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94c95ae0f44c5915e736b92c99e4094"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#af94c95ae0f44c5915e736b92c99e4094">mainBeautyPassCustomTokenString</a> ()</td></tr>
<tr class="memdesc:af94c95ae0f44c5915e736b92c99e4094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the custom token string of the main beauty pass for use by renderers in file naming.  <a href="class_m_render_util.html#af94c95ae0f44c5915e736b92c99e4094">More...</a><br></td></tr>
<tr class="separator:af94c95ae0f44c5915e736b92c99e4094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1711d51473adf93b08fb964faf9fc01"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ad1711d51473adf93b08fb964faf9fc01">mainBeautyPassName</a> ()</td></tr>
<tr class="memdesc:ad1711d51473adf93b08fb964faf9fc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the main beauty pass for use by renderers for token substitution.  <a href="class_m_render_util.html#ad1711d51473adf93b08fb964faf9fc01">More...</a><br></td></tr>
<tr class="separator:ad1711d51473adf93b08fb964faf9fc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326abfa8e93c48c2577e3075c31086b0"><td class="memItemLeft" translate="no" align="right" valign="top">static float&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a326abfa8e93c48c2577e3075c31086b0">diffuseReflectance</a> (const void *lightBlindData, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;lightDirection, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;pointCamera, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;normal, bool lightBackFace, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a326abfa8e93c48c2577e3075c31086b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility function computes and returns the diffuse or lambertian reflectance for a given light source and surface.  <a href="class_m_render_util.html#a326abfa8e93c48c2577e3075c31086b0">More...</a><br></td></tr>
<tr class="separator:a326abfa8e93c48c2577e3075c31086b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac661d16378d8359ffe0e6efa34ab0942"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ac661d16378d8359ffe0e6efa34ab0942">maximumSpecularReflection</a> (const void *lightBlindData, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;lightDirection, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;pointCamera, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;normal, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;rayDirection, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ac661d16378d8359ffe0e6efa34ab0942"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility function computes and returns the vector corresponding to the point on the light source that provides the maximum specular reflection.  <a href="class_m_render_util.html#ac661d16378d8359ffe0e6efa34ab0942">More...</a><br></td></tr>
<tr class="separator:ac661d16378d8359ffe0e6efa34ab0942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4648b18fba6c92b505c523d4475291d"><td class="memItemLeft" translate="no" align="right" valign="top">static float&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ad4648b18fba6c92b505c523d4475291d">lightAttenuation</a> (const void *lightBlindData, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;pointCamera, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;normal, bool lightBackFace, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ad4648b18fba6c92b505c523d4475291d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility function computes and returns light attentuation factor of a light.  <a href="class_m_render_util.html#ad4648b18fba6c92b505c523d4475291d">More...</a><br></td></tr>
<tr class="separator:ad4648b18fba6c92b505c523d4475291d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5237ebe21e824d53e2c021dd93d029"><td class="memItemLeft" translate="no" align="right" valign="top">static float&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#acd5237ebe21e824d53e2c021dd93d029">hemisphereCoverage</a> (const void *lightBlindData, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;lightDirection, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;pointCamera, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;rayDirection, bool lightBackFace, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:acd5237ebe21e824d53e2c021dd93d029"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility function computes and returns the fraction of the light that is transmitted by an object.  <a href="class_m_render_util.html#acd5237ebe21e824d53e2c021dd93d029">More...</a><br></td></tr>
<tr class="separator:acd5237ebe21e824d53e2c021dd93d029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fc51fa6b466082fd630ad0df3072d1"><td class="memItemLeft" translate="no" align="right" valign="top">static void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a06fc51fa6b466082fd630ad0df3072d1">sendRenderProgressInfo</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;pixFile, int percentageDone)</td></tr>
<tr class="memdesc:a06fc51fa6b466082fd630ad0df3072d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility function sends batch rendering status to Maya.  <a href="class_m_render_util.html#a06fc51fa6b466082fd630ad0df3072d1">More...</a><br></td></tr>
<tr class="separator:a06fc51fa6b466082fd630ad0df3072d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c645a9722b143fd6ba1631dfcfd7d1"><td class="memItemLeft" translate="no" align="right" valign="top">static void&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a64c645a9722b143fd6ba1631dfcfd7d1">getCommonRenderSettings</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_common_render_settings_data.html">MCommonRenderSettingsData</a> &amp;rgData)</td></tr>
<tr class="memdesc:a64c645a9722b143fd6ba1631dfcfd7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the set of common render setting values.  <a href="class_m_render_util.html#a64c645a9722b143fd6ba1631dfcfd7d1">More...</a><br></td></tr>
<tr class="separator:a64c645a9722b143fd6ba1631dfcfd7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da24240eff149c2544a952baa9b50fa"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a0da24240eff149c2544a952baa9b50fa">renderObjectItem</a> (const void *objectId, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_selection_list.html">MSelectionList</a> &amp;item)</td></tr>
<tr class="memdesc:a0da24240eff149c2544a952baa9b50fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure to look up a selection item for a given sample object id.  <a href="class_m_render_util.html#a0da24240eff149c2544a952baa9b50fa">More...</a><br></td></tr>
<tr class="separator:a0da24240eff149c2544a952baa9b50fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memItemLeft" translate="no" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this class.  <a href="class_m_render_util.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab946308e39ee33bf4c7ef07dae2ee3"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a2ab946308e39ee33bf4c7ef07dae2ee3">eval2dTexture</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;texNode, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> &amp;uCoords, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> &amp;vCoords, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_vector_array.html">MVectorArray</a> *resultColors, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> *resultAlphas)</td></tr>
<tr class="memdesc:a2ab946308e39ee33bf4c7ef07dae2ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a supported texture node is given, this method can be called to evaluate that texture at a number of (u,v) texture coordinate values.  <a href="class_m_render_util.html#a2ab946308e39ee33bf4c7ef07dae2ee3">More...</a><br></td></tr>
<tr class="separator:a2ab946308e39ee33bf4c7ef07dae2ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8f6680130403e05c24da486597b82c"><td class="memItemLeft" translate="no" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a8d8f6680130403e05c24da486597b82c">noiseTableSize</a> ()</td></tr>
<tr class="memdesc:a8d8f6680130403e05c24da486597b82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the size of Maya's noise table.  <a href="class_m_render_util.html#a8d8f6680130403e05c24da486597b82c">More...</a><br></td></tr>
<tr class="separator:a8d8f6680130403e05c24da486597b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dff67c019e1716dd29b8cf4af2d8f2c"><td class="memItemLeft" translate="no" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a8dff67c019e1716dd29b8cf4af2d8f2c">noiseTableCubeSide</a> ()</td></tr>
<tr class="memdesc:a8dff67c019e1716dd29b8cf4af2d8f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of Maya's noise table is a perfect cube.  <a href="class_m_render_util.html#a8dff67c019e1716dd29b8cf4af2d8f2c">More...</a><br></td></tr>
<tr class="separator:a8dff67c019e1716dd29b8cf4af2d8f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af45a5223ef6b235a67e607e30e7f84"><td class="memItemLeft" translate="no" align="right" valign="top">static float&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a9af45a5223ef6b235a67e607e30e7f84">valueInNoiseTable</a> (unsigned int index)</td></tr>
<tr class="memdesc:a9af45a5223ef6b235a67e607e30e7f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw value from Maya's noise table at the given index.  <a href="class_m_render_util.html#a9af45a5223ef6b235a67e607e30e7f84">More...</a><br></td></tr>
<tr class="separator:a9af45a5223ef6b235a67e607e30e7f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accafe3f2904fcb55601a320776791b67"><td class="memItemLeft" translate="no" align="right" valign="top">static float&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#accafe3f2904fcb55601a320776791b67">noise1</a> (float x)</td></tr>
<tr class="memdesc:accafe3f2904fcb55601a320776791b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates continous non-repeating one dimensional noise based on Maya's internal noise table.  <a href="class_m_render_util.html#accafe3f2904fcb55601a320776791b67">More...</a><br></td></tr>
<tr class="separator:accafe3f2904fcb55601a320776791b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3895302bee1314f4a49d5219ca11c337"><td class="memItemLeft" translate="no" align="right" valign="top">static float&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a3895302bee1314f4a49d5219ca11c337">noise2</a> (float x, float y)</td></tr>
<tr class="memdesc:a3895302bee1314f4a49d5219ca11c337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates continous non-repeating two dimensional noise based on Maya's internal noise table.  <a href="class_m_render_util.html#a3895302bee1314f4a49d5219ca11c337">More...</a><br></td></tr>
<tr class="separator:a3895302bee1314f4a49d5219ca11c337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71568d356b4961989e18cb154b912b95"><td class="memItemLeft" translate="no" align="right" valign="top">static float&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a71568d356b4961989e18cb154b912b95">noise3</a> (float x, float y, float z)</td></tr>
<tr class="memdesc:a71568d356b4961989e18cb154b912b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates continous non-repeating three dimensional noise based on Maya's internal noise table.  <a href="class_m_render_util.html#a71568d356b4961989e18cb154b912b95">More...</a><br></td></tr>
<tr class="separator:a71568d356b4961989e18cb154b912b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b9c389440a6ea3048590eb60b2ec3a"><td class="memItemLeft" translate="no" align="right" valign="top">static float&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a31b9c389440a6ea3048590eb60b2ec3a">noise4</a> (float x, float y, float z, float t, unsigned short numTimeSteps)</td></tr>
<tr class="memdesc:a31b9c389440a6ea3048590eb60b2ec3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates continous four dimensional (space + time) noise based on Maya's internal noise table.  <a href="class_m_render_util.html#a31b9c389440a6ea3048590eb60b2ec3a">More...</a><br></td></tr>
<tr class="separator:a31b9c389440a6ea3048590eb60b2ec3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a04a6ed8afe0aa15ec3ab40df97a02251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">enum <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251">MRenderState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the current rendering state of Maya. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a04a6ed8afe0aa15ec3ab40df97a02251a2ae5259a1e5c4202a18145d34473b7b6"></a>kNotRendering&#160;</td><td class="fielddoc">
<p>Not rendering. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a04a6ed8afe0aa15ec3ab40df97a02251acc4d94cbd95f4ddf20b9d4c227fd201e"></a>kBatchRender&#160;</td><td class="fielddoc">
<p>Performing a batch render. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a04a6ed8afe0aa15ec3ab40df97a02251a69aee1f9b7b6b2bfc771b00258d9d01e"></a>kInteractiveRender&#160;</td><td class="fielddoc">
<p>Performing an interactive render. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a04a6ed8afe0aa15ec3ab40df97a02251a507b3cef2cfa738dd3cc29852a262b00"></a>kIprRender&#160;</td><td class="fielddoc">
<p>Performing an IPR render. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a04a6ed8afe0aa15ec3ab40df97a02251ae833a6de784804e1d4f15c2fad018f6f"></a>kHardwareRender&#160;</td><td class="fielddoc">
<p>Performing a hardware render. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab15600fa49838d1c2b4d4c3ba73c41da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">enum <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41da">MRenderPass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the current pass of Maya. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab15600fa49838d1c2b4d4c3ba73c41daa8d857bf5569760ac7306382a558cb092"></a>kAll&#160;</td><td class="fielddoc">
<p>Default case, compute everything. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab15600fa49838d1c2b4d4c3ba73c41daa3ffb5a65daa385aafe521dca897a1c42"></a>kColorOnly&#160;</td><td class="fielddoc">
<p>Compute only color information, no shadows. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab15600fa49838d1c2b4d4c3ba73c41daa059ab4a7af031ed9d02ecb004ae09ce1"></a>kShadowOnly&#160;</td><td class="fielddoc">
<p>Compute only shadow information, no color. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab15600fa49838d1c2b4d4c3ba73c41daabf3fd40258f099e6519ba09d6041b79f"></a>kAmbientOnly&#160;</td><td class="fielddoc">
<p>Compute only ambient information. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab15600fa49838d1c2b4d4c3ba73c41daa71c7c30537ed19af65653b3ffdd6ca2a"></a>kDiffuseOnly&#160;</td><td class="fielddoc">
<p>Compute only diffuse information. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab15600fa49838d1c2b4d4c3ba73c41daa6bbfaadb24b835d76a23e720376782ab"></a>kSpecularOnly&#160;</td><td class="fielddoc">
<p>Compute only specular information. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a75ba1ad417f7867b4a064d690ceabba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">OPENMAYA_MAJOR_NAMESPACE_OPEN <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251">MRenderUtil::MRenderState</a> mayaRenderState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerated type specifying the current state of the Maya renderer. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251a2ae5259a1e5c4202a18145d34473b7b6" title="Not rendering. ">MRenderUtil::kNotRendering</a></b> Maya is not currently rendering </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251acc4d94cbd95f4ddf20b9d4c227fd201e" title="Performing a batch render. ">MRenderUtil::kBatchRender</a></b> Maya is performing a batch render </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251a69aee1f9b7b6b2bfc771b00258d9d01e" title="Performing an interactive render. ">MRenderUtil::kInteractiveRender</a></b> Maya is performing an interactive render </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251a507b3cef2cfa738dd3cc29852a262b00" title="Performing an IPR render. ">MRenderUtil::kIprRender</a></b> Maya is performing an IPR render </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a04a6ed8afe0aa15ec3ab40df97a02251ae833a6de784804e1d4f15c2fad018f6f" title="Performing a hardware render. ">MRenderUtil::kHardwareRender</a></b> Maya is performing a hardware render </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a228b2661ed753557a3b48a29321d3417"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> raytrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rayOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rayDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>notUsed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>raySampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short&#160;</td>
          <td class="paramname"><em>rayDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>resultColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>resultTransparency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isReflectedRays</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility method provides functionality to raytrace from within a shader plug-in. </p>
<p>This method shoots a single ray given a ray origin and a ray direction, and returns the color and transparency of the result.</p>
<p>In order for a shader plug-in to raytrace, the following steps are necessary:</p>
<p>raySampler is needed from the renderer. This can be obtained by creating an input attribute named 'raySampler' (rtr).</p>
<p>rayDepth is needed from the renderer. This can be obtained by creating an input attribute named 'rayDepth' (rd).</p>
<p>The "Enable Raytracing" flag needs to be turned on in renderGlobal-&gt; renderQuality-&gt;raytracing.</p>
<p>isReflectedRays tells if these rays are for reflection or refraction. This allows the raytracer to check the corresponding ray depth limit under renderGlobal-&gt;renderQuality for terminating the rays.</p>
<p>All objects to be seen by the raytracer need to have their "Visible
In Reflections" or "Visible In Refraction" flags turned on.</p>
<p>This method only works in the software renderer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rayOrigin</td><td>Origin of the ray to shoot from in camera space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>Direction of the ray to shoot at in camera space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notUsed</td><td>unused argument left for compatibility </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">raySampler</td><td>Pointer to the raytracer from the renderer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rayDepth</td><td>Current ray depth from the renderer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultColor</td><td>Storage for the result color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultTransparency</td><td>Storage for the result transparency </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isReflectedRays</td><td>true for reflected rays (default), false for refracted rays</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code <ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kInvalidParameter</b> Raytracing failed due to bad raySampler pointer passed in. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example0" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example0-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example0-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/phong_shader_2phong_shader_8cpp-example.html#a47">phongShader/phongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="afe4aa707b8b78542a961a5d9ba2e96f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> raytrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rayOrigins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rayDirections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>notUsed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>raySampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short&#160;</td>
          <td class="paramname"><em>rayDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultTransparencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isReflectedRays</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility method provides functionality to raytrace from within a shader plug-in. </p>
<p>This method shoots a number of rays given ray origins and ray directions, and returns the colors and transparencies of the results.</p>
<p>The size of rayOrigins, rayDirections, colors, and transparencies arrays must be the same.</p>
<p>In order for a shader plug-in to raytrace, the following steps are necessary:</p>
<p>raySampler is needed from the renderer. This can be obtained by creating an input attribute named 'raySampler' (rtr).</p>
<p>rayDepth is needed from the renderer. This can be obtained by creating an input attribute named 'rayDepth' (rd).</p>
<p>The "Enable Raytracing" flag needs to be turned on in renderGlobal-&gt; renderQuality-&gt;raytracing.</p>
<p>isReflectedRays tells if these rays are for reflection or refraction. This allows the raytracer to check the corresponding ray depth limit under renderGlobal-&gt;renderQuality for terminating the rays.</p>
<p>All objects to be seen by the raytracer need to have their "Visible
In Reflections" or "Visible In Refraction" flags turned on.</p>
<p>This method only works in the software renderer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rayOrigins</td><td>Origins of the ray to shoot from in camera space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rayDirections</td><td>Directions of the ray to shoot at in camera space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notUsed</td><td>unused argument left for compatability </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">raySampler</td><td>Pointer to the raytracer from the renderer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rayDepth</td><td>Current ray depth from the renderer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultColors</td><td>Storage for the result colors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultTransparencies</td><td>Storage for the result transparencies </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isReflectedRays</td><td>true for reflected rays (default), false for refracted rays</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code <ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kIndexOutOfRange</b> Array size do not match. </li>
<li><b>MS::kInvalidParameter</b> Raytracing failed due to bad raySampler pointer passed in. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aeb868fb03dcccdb9fb6d18f7f93c834c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> raytraceFirstGeometryIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rayOrigins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rayDirections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>notUsed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>raySampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultIntersections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_int_array.html">MIntArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultIntersected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility method provides functionality to find the location of the first geometry intersected by a ray from within a shader plug-in. </p>
<p>This method shoots a number of rays given ray origins and ray directions, and returns whether the rays intersected anything, and if so, the locations of the first geometry intersected in camera space. The plug-in should check the resultIntersected values to see if a ray has intersected any geometry (0 = no geometry intersected, 1 = geometry intersected).</p>
<p>The size of rayOrigins, rayDirections, resultIntersections, and resultIntersected arrays must be the same.</p>
<p>In order for a shader plug-in to raytrace, the following steps are necessary:</p>
<p>raySampler is needed from the renderer. This can be obtained by creating an input attribute named 'raySampler' (rtr).</p>
<p>The "Enable Raytracing" flag needs to be turned on in renderGlobal-&gt; renderQuality-&gt;raytracing.</p>
<p>All objects to be seen by the raytracer need to have their "Visible
In Reflections" flags turned on.</p>
<p>This method only works in the software renderer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rayOrigins</td><td>Origins of the ray to shoot from in camera space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rayDirections</td><td>Directions of the ray to shoot at in camera space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notUsed</td><td>unused argument left for compatability </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">raySampler</td><td>Pointer to the raytracer from the renderer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultIntersections</td><td>Storage for the result intersection locations in camera space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultIntersected</td><td>Storage for the result intersected flags (0 = no geometry intersected, 1 = geometry intersected)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code <ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kIndexOutOfRange</b> Array size do not match. </li>
<li><b>MS::kInvalidParameter</b> Raytracing failed due to bad raySampler pointer passed in. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6b9ba1907baa091db043c29581c963fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> sampleShadingNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td>
          <td class="paramname"><em>shadingNodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useShadowMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reuseMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_matrix.html">MFloatMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>cameraMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_point_array.html">MFloatPointArray</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> *&#160;</td>
          <td class="paramname"><em>uCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> *&#160;</td>
          <td class="paramname"><em>vCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> *&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_point_array.html">MFloatPointArray</a> *&#160;</td>
          <td class="paramname"><em>refPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> *&#160;</td>
          <td class="paramname"><em>tangentUs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> *&#160;</td>
          <td class="paramname"><em>tangentVs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> *&#160;</td>
          <td class="paramname"><em>filterSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector_array.html">MFloatVectorArray</a> &amp;&#160;</td>
          <td class="paramname"><em>resultTransparencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility method allows you to sample a shading node/shading engine. </p>
<p>You can specify the location and property of the sample point, and the method will return the result color and transparency. If you are sampling a shading engine, and there are lights in the scene, you can optionally request shadows to be computed as well.</p>
<p>If you specify a shading node to be evaluated, you'll need to provide the attribute to be evaluated. For example, valid shading nodes are checker1.outAlpha, file1.outColor, etc.</p>
<p>If you specify a shading engine to be evaluated, only the name will be needed. For example, valid shading engines are initialShadingGroup, phong1SG, etc.</p>
<p>Since setting up sampling is an expensive operation, try to pass in as many sample points at one time as possible and let the sampler process them in batch. Try to avoid calling the sampler with just one sample.</p>
<p>For extremely complicated shading networks, it is possible that passing in too many samples in one batch will cause a stack overflow. If this condition occurs, simply reduce the number of samples per batch.</p>
<p>Certain type of shading network requires certain type of input, and not all inputs are needed. For example, a 2D texture such as file or checker does not need point/normal/tangent information. Pass in NULL for parameters which are not needed.</p>
<p>In general, 2D textures require UV coordinates, 3D textures require points and refPoints, lighting calculations require points and normals.</p>
<p>To calculate camera space related shaders, such as hilights in a phong shader, an eye to world matrix needs to be supplied. This matrix is used to convert supplied world coordinates into camera coordinate. The matrix can be obtained by getting the inclusive matrix of the camera's DAG node.</p>
<p>This method can be used in both interactive and batch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shadingNodeName</td><td>Name of the shading node/shading engine </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSamples</td><td>Number of samples to be calculated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useShadowMaps</td><td>Whether to calculate shadows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reuseMaps</td><td>If calculating shadows, whether to reuse shadowmaps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraMatrix</td><td>The eyeToWorld matrix to be used for conversion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Locations to be sampled in world space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uCoords</td><td>U coordinates of the samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vCoords</td><td>V coordinates of the samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normals</td><td>Normals at the sample points in world space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refPoints</td><td>RefPoints to be used for 3D texture in world space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tangentUs</td><td>U tangents at the sample points in world space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tangentVs</td><td>V tangents at the sample points in world space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterSizes</td><td>Filter sizes to be used for 2D/3D textures </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultColors</td><td>Storage for result colors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resultTransparencies</td><td>storage for result transparencies</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code <ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kNoModelActive</b> Unable to get the active model </li>
<li><b>MS::kObjectDoesNotExist</b> Unable to find the specified shadingNodeName </li>
<li><b>MS::kInvalidDataType</b> Specified node is not a shading engine </li>
<li><b>MS::kFailure</b> Failed to sample the given shading network </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example1" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example1-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example1-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/sample_cmd_2sample_cmd_8cpp-example.html#a34">sampleCmd/sampleCmd.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/sample_particles_2sample_particles_8cpp-example.html#a25">sampleParticles/sampleParticles.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a93eb671899250f03b16ec74e7ce70ce9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool generatingIprFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if an IPR file is being created. </p>
<p>This can be used to optimize the IPR file. Lights do not need to request particle information (IPR does not support particle rendering) when creating a IPR file.</p>
<dl class="section return"><dt>Returns</dt><dd>true if IPR file is being generated, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2909a1a35a376470df355e520cb81b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> relativeFileName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>absFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract relative file name from the given (absolute) file name. </p>
<p>If the given file name does not begin with a project root, return value is same as the input file name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">absFileName</td><td>input file name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>file name without the project path</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kInvalidParameter</b> absFileName is empty </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a419f62773e2626b29666ca4dd2cf5370"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool exactFileTextureName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>fileNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>texturePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to resolve the file texture name specified on a file texture node into an absolute path to an image file on disk. </p>
<p>The function applies exactly the same logic that is used by the file texture node internally for resolving the image file path.</p>
<dl class="section user"><dt>Python Notes:</dt><dd></dd></dl>
<p>This method is not supported in Python. See the version which returns a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileNode</td><td>a file texture node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">texturePath</td><td>returns an absolute pathname to the texture file referenced by the node. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the image file pathname was successfully resolved, false otherwise.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kInvalidParameter</b> fileNode pointer is not a valid file texture node. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example2" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example2-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example2-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/file_texture_2file_texture_8cpp-example.html#a26">fileTexture/fileTexture.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a3e9b48654b87d16fe79b9e08c7b72c64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool exactFileTextureName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFrameExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>currentFrameExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>exactName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>obsolete, use the one with contextNodeFullName param </p>
<p><b>This method is obsolete.</b></p>
<p><b>This method is obsolete.</b> [From Maya 2019] </p><dl class="deprecated"><dt><b><a class="el" translate="no" href="#!/url=./cpp_ref/deprecated.html#_deprecated000391">Deprecated:</a></b></dt><dd>Context (owner Node full name) must be provided to the Maya resolver. Use the one with the contextNodeFullName input param. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" translate="no" href="#!/url=./cpp_ref/deprecated.html#_deprecated000389">Deprecated:</a></b></dt><dd>Context (owner Node full name) must be provided to the Maya resolver. Use the one with the contextNodeFullName input param.</dd></dl>
<p>Attempts to resolve the file name specified into an absolute path to a file on disk. The function applies exactly the same logic that is used by the file texture node internally for resolving the image file path.</p>
<dl class="section user"><dt>Python Notes:</dt><dd></dd></dl>
<p>This method is not supported in Python. See the version which returns a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseName</td><td>a file name to be resolved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useFrameExt</td><td>use frame extension for image file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currentFrameExt</td><td>specify a frame extension if useFrameExt is used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exactName</td><td>resolved file name with absolute path </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true if the file pathname was successfully resolved. </li>
<li>false if the pathname could not be resolved.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4cdc7ff71c27bf1e3e05220453da8225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool exactFileTextureName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFrameExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>currentFrameExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>contextNodeFullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>exactName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to resolve the file name specified into an absolute path to a file on disk. </p>
<p>The function applies exactly the same logic that is used by the file texture node internally for resolving the image file path.</p>
<dl class="section user"><dt>Python Notes:</dt><dd></dd></dl>
<p>This method is not supported in Python. See the version which returns a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseName</td><td>a file name to be resolved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useFrameExt</td><td>use frame extension for image file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currentFrameExt</td><td>specify a frame extension if useFrameExt is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextNodeFullName</td><td>full name of the file owner Node. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exactName</td><td>resolved file name with absolute path </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true if the file pathname was successfully resolved. </li>
<li>false if the pathname could not be resolved.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8b8c405e8dbbe4776c5a6bdc64945337"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool exactFileTextureUvTileData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>fileNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> &amp;&#160;</td>
          <td class="paramname"><em>tilePaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_array.html">MFloatArray</a> &amp;&#160;</td>
          <td class="paramname"><em>tilePositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to resolve all the paths to UV tiles for the given file texture node into absolute paths to image files on disk. </p>
<p>Also computes the lower left coordinate of each tile in UV space. The coordinates are returned in a flat array of floats so for tile 'n', the coordinate is given by: (tilePositions[n*2], tilePositions[n*2+1]).</p>
<p>This function applies exactly the same logic that is used by the file texture node internally for resolving the UV tile paths and positions.</p>
<dl class="section user"><dt>Python Notes:</dt><dd></dd></dl>
<p>This method is not supported in Python.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileNode</td><td>A file texture node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tilePaths</td><td>Returns the set of absolute pathnames to the UV tiles for the given texture texture file node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tilePositions</td><td>Returns the lower left coordinate of each tile in UV space. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one tile was resolved, false otherwise.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kInvalidParameter</b> fileNode pointer is not a valid file texture node. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a159bc820f6f90b218d74b49444a649af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool convertPsdFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>fileNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>texturePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>forExport</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. </p>
<p>This method converts a Psd file texture to an IFF file that can be used by Maya.</p>
<p>It writes out the current layer set image the file node. The intermediate image will be either 8 or 16 b.p.c, based on the input psd file.</p>
<dl class="section user"><dt>Python Notes:</dt><dd></dd></dl>
<p>This method is not supported in Python. See the version which returns a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileNode</td><td>a file texture node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">texturePath</td><td>returns an absolute pathname to the texture file referenced by the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forExport</td><td>if true the resulting IFF file will be stored in the project directory tree, otherwise it will be stored in a temporary file which will be deleted when Maya exits. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true if the image file pathname was successfully resolved and exporting psd file is succeeded. </li>
<li>false if the pathname could not be resolved or exporting psd file fails.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kInvalidObjectType</b> fileNode pointer is not a valid file texture node. </li>
<li><b>MS::kInvalidParameter</b> fileNode has empty file name string </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="acedd58b582f49bb34904677dd52b5b43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool exactImagePlaneFileName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>imagePlaneNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>texturePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to resolve the file texture name specified on an image plane node into an absolute path to an image file on disk. </p>
<p>The function applies exactly the same logic that is used by the image plane node internally for resolving the image file path.</p>
<dl class="section user"><dt>Python Notes:</dt><dd></dd></dl>
<p>This method is not supported in Python. See the version which returns a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imagePlaneNode</td><td>an image plane node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">texturePath</td><td>returns an absolute pathname to the texture file referenced by the node. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true if the image file pathname was successfully resolved. </li>
<li>false if the pathname could not be resolved.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kInvalidParameter</b> imagePlaneNode pointer is not a valid image plane node. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a606ecc4f9e73be82a731c67664e1645c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> exactFileTextureName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>fileNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to resolve the file texture name specified on a file texture node into an absolute path to an image file on disk. </p>
<p>The function applies exactly the same logic that is used by the file texture node internally for resolving the image file path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileNode</td><td>a file texture node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An absolute pathname to the texture file referenced by the node. If the path cannot be resolved than an empty string is returned</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kInvalidParameter</b> fileNode pointer is not a valid file texture node. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3336c4390d5092c3d929ebdd38ead524"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> exactFileTextureName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFrameExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>currentFrameExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>obsolete, use the one with contextNodeFullName param </p>
<p><b>This method is obsolete.</b></p>
<p><b>This method is obsolete.</b> [From Maya 2019] </p><dl class="deprecated"><dt><b><a class="el" translate="no" href="#!/url=./cpp_ref/deprecated.html#_deprecated000392">Deprecated:</a></b></dt><dd>Context (owner Node full name) must be provided to the Maya resolver. Use the one with the contextNodeFullName input param. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" translate="no" href="#!/url=./cpp_ref/deprecated.html#_deprecated000390">Deprecated:</a></b></dt><dd>Context (owner Node full name) must be provided to the Maya resolver. Use the one with the contextNodeFullName input param.</dd></dl>
<p>Attempts to resolve the file name specified into an absolute path to a file on disk. The function applies exactly the same logic that is used by the file texture node internally for resolving the image file path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseName</td><td>a file name to be resolved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useFrameExt</td><td>use frame extension for image file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currentFrameExt</td><td>specify a frame extension if useFrameExt is used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An absolute path to the texture based on its file name. If the path cannot be resolved, then an empty string is returned.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a569c5e0877ab2e07a147b9fab137d4ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> exactFileTextureName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useFrameExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>currentFrameExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>contextNodeFullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to resolve the file name specified into an absolute path to a file on disk. </p>
<p>The function applies exactly the same logic that is used by the file texture node internally for resolving the image file path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseName</td><td>a file name to be resolved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useFrameExt</td><td>use frame extension for image file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currentFrameExt</td><td>specify a frame extension if useFrameExt is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextNodeFullName</td><td>full name of the file owner Node. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An absolute path to the texture based on its file name. If the path cannot be resolved, then an empty string is returned.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4c1e7db93c17c4e8537a2db21f6d6b00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> convertPsdFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>fileNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>forExport</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. </p>
<p>This method converts a Psd file texture to an IFF file that can be used by Maya.</p>
<p>It writes out the current layer set image the file node. The intermediate image will be either 8 or 16 b.p.c, based on the input psd file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileNode</td><td>a file texture node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forExport</td><td>if true the resulting IFF file will be stored in the project directory tree, otherwise it will be stored in a temporary file which will be deleted when Maya exits. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true if the image file pathname was successfully resolved and exporting psd file is succeeded. </li>
<li>false if the pathname could not be resolved or exporting psd file fails.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kInvalidObjectType</b> fileNode pointer is not a valid file texture node. </li>
<li><b>MS::kInvalidParameter</b> fileNode has empty file name string </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab5ba20f25e88ad324b66338533cef000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> exactImagePlaneFileName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>imagePlaneNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to resolve the file texture name specified on an image plane node into an absolute path to an image file on disk. </p>
<p>The function applies exactly the same logic that is used by the image plane node internally for resolving the image file path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imagePlaneNode</td><td>an image plane node </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An absolute pathname to the texture file referenced by the node. If the pathname cannot be resolved, then the returned string is empty</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Return is valid </li>
<li><b>MS::kInvalidParameter</b> imagePlaneNode pointer is not a valid image plane node. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a330ffaa4fa8fe2c3dc1e3ea826d3dad8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool inCurrentRenderLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_dag_path.html">MDagPath</a> &amp;&#160;</td>
          <td class="paramname"><em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified path is in the current render layer. </p>
<p>If the object at the end of the DAG path has not been assigned to any layer, then each node in hierarchy from bottom up will be tested whether its contained in the current render layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objectPath</td><td>Path of object to test </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object is in the current render layer.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Success </li>
<li><b>MS::kFailure</b> Invalid object </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1fe25fe2c0429e689f46d5aa734957d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41da">MRenderUtil::MRenderPass</a> renderPass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an enumerated type specifying the current pass the Maya renderer is executing. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa8d857bf5569760ac7306382a558cb092" title="Default case, compute everything. ">MRenderUtil::kAll</a></b> Default case. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa3ffb5a65daa385aafe521dca897a1c42" title="Compute only color information, no shadows. ">MRenderUtil::kColorOnly</a></b> Only color information is being calculated. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa059ab4a7af031ed9d02ecb004ae09ce1" title="Compute only shadow information, no color. ">MRenderUtil::kShadowOnly</a></b> Only shadow information is being calculated. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daabf3fd40258f099e6519ba09d6041b79f" title="Compute only ambient information. ">MRenderUtil::kAmbientOnly</a></b> Only ambient information is being calculated. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa71c7c30537ed19af65653b3ffdd6ca2a" title="Compute only diffuse information. ">MRenderUtil::kDiffuseOnly</a></b> Only diffuse information is being calculated. </li>
<li><b><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#ab15600fa49838d1c2b4d4c3ba73c41daa6bbfaadb24b835d76a23e720376782ab" title="Compute only specular information. ">MRenderUtil::kSpecularOnly</a></b> Only specular information is being calculated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af94c95ae0f44c5915e736b92c99e4094"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> mainBeautyPassCustomTokenString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the custom token string of the main beauty pass for use by renderers in file naming. </p>
<dl class="section return"><dt>Returns</dt><dd>The custom token string for the main beauty pass </dd></dl>

</div>
</div>
<a class="anchor" id="ad1711d51473adf93b08fb964faf9fc01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> mainBeautyPassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the main beauty pass for use by renderers for token substitution. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the main beauty pass </dd></dl>

</div>
</div>
<a class="anchor" id="a326abfa8e93c48c2577e3075c31086b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">float diffuseReflectance </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>lightBlindData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lightDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pointCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lightBackFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility function computes and returns the diffuse or lambertian reflectance for a given light source and surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightBlindData</td><td>The reference to the aLightBlindData attribute of the current light being evaluated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lightDirection</td><td>The direction of the light being evaluated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointCamera</td><td>The position of the camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normal</td><td>The surface normal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lightBackFace</td><td>Is the back face being lit, true or false. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section "><div id="dynsection-example3" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example3-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example3-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/phong_shader_2phong_shader_8cpp-example.html#a42">phongShader/phongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ac661d16378d8359ffe0e6efa34ab0942"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> maximumSpecularReflection </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>lightBlindData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lightDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pointCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rayDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility function computes and returns the vector corresponding to the point on the light source that provides the maximum specular reflection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightBlindData</td><td>The reference to the aLightBlindData attribute of the current light being evaluated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lightDirection</td><td>The direction of the light being evaluated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointCamera</td><td>The position of the camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normal</td><td>The surface normal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>The direction of the current intersection ray in camera space </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section "><div id="dynsection-example4" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example4-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example4-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/phong_shader_2phong_shader_8cpp-example.html#a43">phongShader/phongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ad4648b18fba6c92b505c523d4475291d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">float lightAttenuation </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>lightBlindData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pointCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lightBackFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility function computes and returns light attentuation factor of a light. </p>
<p>Note that the result of 1 will be returned if the light being evaluated does not support light attentuation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightBlindData</td><td>The reference to the aLightBlindData attribute of the current light being evaluated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointCamera</td><td>The position of the camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normal</td><td>The surface normal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lightBackFace</td><td>Is the back face being lit, true or false. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section "><div id="dynsection-example5" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example5-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example5-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/phong_shader_2phong_shader_8cpp-example.html#a44">phongShader/phongShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="acd5237ebe21e824d53e2c021dd93d029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">float hemisphereCoverage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>lightBlindData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lightDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pointCamera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_float_vector.html">MFloatVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rayDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lightBackFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility function computes and returns the fraction of the light that is transmitted by an object. </p>
<p>It is mostly used for translucence and scattering effects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightBlindData</td><td>The reference to the aLightBlindData attribute of the current light being evaluated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lightDirection</td><td>The direction of the light being evaluated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointCamera</td><td>The position of the camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rayDirection</td><td>The direction of the current intersection ray in camera space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lightBackFace</td><td>Is the back face being lit, true or false. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>Status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06fc51fa6b466082fd630ad0df3072d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void sendRenderProgressInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>pixFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>percentageDone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility function sends batch rendering status to Maya. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pixFile</td><td>File name of the last rendered batch image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">percentageDone</td><td>percentage rendered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64c645a9722b143fd6ba1631dfcfd7d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">void getCommonRenderSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_common_render_settings_data.html">MCommonRenderSettingsData</a> &amp;&#160;</td>
          <td class="paramname"><em>mrgData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the set of common render setting values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mrgData</td><td>Render settings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0da24240eff149c2544a952baa9b50fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> renderObjectItem </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>objectId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_selection_list.html">MSelectionList</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure to look up a selection item for a given sample object id. </p>
<p>This is only guaranteed to work when software rendering. As multiple processors may be used when software rendering; a critical section should be used to protect multiple threads from simulaneously performing DG evaluation. This includes querying attribute values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objectId</td><td>The sample object id to look-up </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>The corresponding item for the id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status Code <ul>
<li><b>MS::kSuccess</b> Returned if valid </li>
<li><b>MS::kInvalidParameter</b> The objectId parameter is NULL </li>
<li><b>MS::kNotFound</b> The item was not found </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example6" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example6-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example6-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/cv_color_shader_2cv_color_shader_8cpp-example.html#a40">cvColorShader/cvColorShader.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a774cd5d8fbebe8e7ed82a5aa587d1f04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">const char * className </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ab946308e39ee33bf4c7ef07dae2ee3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> eval2dTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object.html">MObject</a> &amp;&#160;</td>
          <td class="paramname"><em>texNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> &amp;&#160;</td>
          <td class="paramname"><em>uCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> &amp;&#160;</td>
          <td class="paramname"><em>vCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_vector_array.html">MVectorArray</a> *&#160;</td>
          <td class="paramname"><em>resultColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_double_array.html">MDoubleArray</a> *&#160;</td>
          <td class="paramname"><em>resultAlphas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a supported texture node is given, this method can be called to evaluate that texture at a number of (u,v) texture coordinate values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">texNode</td><td>texture node to evaluate. It doesn't need to be connected to anything. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uCoords</td><td>array of u coordinate values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vCoords</td><td>array of v coordinate values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultColors</td><td>if non-NULL, receives the result of the connected texture's outColor attribute, evaluated at all the (u,v) coordinates given by the uCoords and vCoords arrays. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultAlphas</td><td>if non-NULL, receives the outAlpha values evaluated from the texture at these same points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> The texture node was successfully evaluated </li>
<li><b>MS::kUnknownParameter</b> There was no texture so textured values could not be evaluated. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8d8f6680130403e05c24da486597b82c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">unsigned int noiseTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the size of Maya's noise table. </p>
<p>The noise table is a constant set of random floating point values in the range [-1.0, 1.0] used by many of Maya's procedural textures.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the noise table </dd></dl>
<dl class="section "><div id="dynsection-example7" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example7-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example7-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/simple_noise_shader_2simple_noise_shader_override_8cpp-example.html#a1">simpleNoiseShader/simpleNoiseShaderOverride.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a8dff67c019e1716dd29b8cf4af2d8f2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">unsigned int noiseTableCubeSide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of Maya's noise table is a perfect cube. </p>
<p>This method returns the cubic root of the table size.</p>
<dl class="section return"><dt>Returns</dt><dd>The cubic root of the size of the noise table </dd></dl>
<dl class="section "><div id="dynsection-example8" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example8-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example8-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/simple_noise_shader_2simple_noise_shader_override_8cpp-example.html#a37">simpleNoiseShader/simpleNoiseShaderOverride.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="a9af45a5223ef6b235a67e607e30e7f84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">float valueInNoiseTable </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw value from Maya's noise table at the given index. </p>
<p>If the index is out of bounds, the index modulo <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_render_util.html#a8d8f6680130403e05c24da486597b82c" title="Access the size of Maya&#39;s noise table. ">noiseTableSize()</a> is used instead. The noise table is a constant set of random floating point values in the range [-1.0, 1.0] used by many of Maya's procedural textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index to retrieve from the noise table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from the noise table in the range [-1.0, 1.0] </dd></dl>
<dl class="section "><div id="dynsection-example9" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example9-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example9-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/simple_noise_shader_2simple_noise_shader_8cpp-example.html#a25">simpleNoiseShader/simpleNoiseShader.cpp</a>, and <a class="el" translate="no" href="#!/url=./cpp_ref/simple_noise_shader_2simple_noise_shader_override_8cpp-example.html#a2">simpleNoiseShader/simpleNoiseShaderOverride.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="accafe3f2904fcb55601a320776791b67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">float noise1 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates continous non-repeating one dimensional noise based on Maya's internal noise table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The one dimensional coordinate for which to generate noise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A noise value that is non-repeating and continuous on the given coordinate </dd></dl>

</div>
</div>
<a class="anchor" id="a3895302bee1314f4a49d5219ca11c337"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">float noise2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates continous non-repeating two dimensional noise based on Maya's internal noise table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x coordinate for which to generate noise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y coordinate for which to generate noise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A noise value that is non-repeating and continuous on the given coordinate </dd></dl>

</div>
</div>
<a class="anchor" id="a71568d356b4961989e18cb154b912b95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">float noise3 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates continous non-repeating three dimensional noise based on Maya's internal noise table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x coordinate for which to generate noise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y coordinate for which to generate noise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The y coordinate for which to generate noise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A noise value that is non-repeating and continuous on the given coordinate </dd></dl>

</div>
</div>
<a class="anchor" id="a31b9c389440a6ea3048590eb60b2ec3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">float noise4 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>numTimeSteps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates continous four dimensional (space + time) noise based on Maya's internal noise table. </p>
<p>The noise will loop in a seamless manner. The larger the value for the numTimeSteps parameter the longer it will take for the noise to loop (i.e. more samples would be required along the time axis to cause the sequence to restart).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x coordinate for which to generate noise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y coordinate for which to generate noise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>The y coordinate for which to generate noise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The time coordinate for which to generate noise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numTimeSteps</td><td>Controls the repetition of the noise with respect to time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A noise value that is continuous on the given coordinate </dd></dl>

</div>
</div>
<hr>The documentation for this class was generated from the following files:<ul>
<li>MRenderUtil.h</li>
<li>MRenderUtil.cpp</li>
<li>MRenderUtil_Sample.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
