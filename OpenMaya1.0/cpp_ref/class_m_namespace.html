<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
   <head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script type="text/javascript" src="../scripts/utils/adsk.redirect.js"></script>
      <title>MNamespace Class Reference</title>
   

<meta name="topic-subtype" content="C++"></head>
   <body height="100%"><div class="body_content" id="body-content"><link rel="stylesheet" type="text/css" href="cpp_ref/navtree.css"><link rel="stylesheet" type="text/css" href="cpp_ref/doxygen.css"><link rel="stylesheet" type="text/css" href="cpp_ref/tabs.css"><link rel="stylesheet" type="text/css" href="style/adsk.cpm.css"><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('class_m_namespace.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type='text/javascript'>$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
            
            <div id='MicrosoftTranslatorWidget' class='Dark' style='float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden'></div>
      <div>
         <div class="head">
            <h1>MNamespace Class Reference</h1>
         </div>

    <div id="top"><!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="#!/url=./cpp_ref/pages.html"><span>Topics</span></a></li>
      <li><a href="#!/url=./cpp_ref/modules.html"><span>Modules</span></a></li>
      <li><a href="#!/url=./cpp_ref/namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="#!/url=./cpp_ref/annotated.html"><span>Classes</span></a></li>
      <li><a href="#!/url=./cpp_ref/files.html"><span>Files</span></a></li>
      <li><a href="#!/url=./cpp_ref/examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="#!/url=./cpp_ref/annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="#!/url=./cpp_ref/classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="#!/url=./cpp_ref/hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="#!/url=./cpp_ref/functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>

<div id="doc-content">
<div class="header">
  
  <div class="headertitle">
<div class="title">MNamespace Class Reference<div class="ingroups"><a class="el" translate="no" href="#!/url=./cpp_ref/group___open_maya.html">OpenMaya - API module for common classes</a></div></div>  </div>
<div id="OverviewLinksDiv"><div id="dynsection-overview" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><img id="dynsection-overview-trigger" src="cpp_ref/closed.png" alt="+"> Related help topics: </div><div id="dynsection-overview-content" class="dyncontent" style="display:none;"><ul class="overviewLinks">
<li class="overviewLink"><a href="#!/url=./developer/What-s-New-What-s-Changed-/What-s-New-in-API-in-Maya-2017-3/New-Python-API-2-0-classes-in.html">What&#39;s New / What&#39;s Changed? &gt; What&#39;s New in API in Maya 2017 &gt; New Python API 2.0 classes in Maya 2017</a></li>
</ul></div></div>
<div class="summary">
<a href="class_m_namespace.html#pub-static-methods">Static Public Member Functions</a>  </div></div><!--header-->
<div class="contents">

<p><code>#include &lt;MNamespace.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><p>Namespace. </p>
<p><b>Overview</b></p>
<p>The <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html" title="Namespace. ">MNamespace</a> class contains methods for efficiently accessing Maya's namespace functionality. In Maya, namespaces form a packaging scheme for defining collections of objects. You can also have a namespace contain other namespaces and thus define a hierarchy. In Maya, namespaces are used by default with file referencing to collect all the objects from the given referenced file. Namespaces are also used for naming UI elements, and of course the user can create namespaces on their own to collect objects together in a logical fashion.</p>
<p>Here are some important definitions:</p>
<p>o Root Namespace: The unnamed namespace at the root of the namespace hierarchy.</p>
<p>o Current Namespace: The currently selected namespace. On startup and after file open and new, Maya assigns the root namespace to be current.</p>
<p>o Absolute Name: An object name that is fully specified from the root downwards (i.e. starts with a leading colon).</p>
<p>o Relative Name: An object name that is relative to the current namespace. Can be enabled via <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a1670b257ba1372a5b68826966bf5d0ac" title="Set relative name lookup mode. ">MNamespace::setRelativeNames()</a>.</p>
<p>o Root-Relative Name: When relative name lookup is turned off, virtually all name lookups in Maya are relative to the root of the namespace hierarchy.</p>
<p><b>About naming rules</b></p>
<p>When specifying the name of an object in a namespace, the namespace name should prefix the name, separated by a colon character (":"). There is a special namespace, the root namespace, which lives at the root of the namespace tree. In effect, the name of the root namespace is the empty string. For example, if we have the object "sphere" and it exists in the root namespace, we could use ":sphere" to identify it.</p>
<p>Since namespaces can be hierarchical, when completely specifying a name one could have several colons and namespaces names in the pathname. If we have the namespace ":a:b:c" that contains the object "sphere", the full namepath for the object would be thus:</p>
<p>:a:b:c:sphere</p>
<p>The leading colon specifies that the namespace lookup occur from the root-level downwards. In effect, the namespace "a" is a child of the root namespace, and "b" is a child of "a", and "c" a child of "b".</p>
<p><b>The current namespace</b></p>
<p>Maya has the concept of a "current" namespace. On startup, this defaults to the root namespace. Some operations within Maya are based off the current namespace. For example, if the 'parent' parameter is not specified to <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#aa3506948f8769aa58fc34cee96172bdb" title="Create the namespace `name&#39;. ">MNamespace::addNamespace()</a> then the newly created namespace will be a child of the current namespace.</p>
<p><b>Relative name lookup</b></p>
<p>Maya actually has the concept of name lookup based off the current namespace as opposed to lookup based off the root-level namespace which is the default behaviour. In relative mode, if we had the object ":a:b:c:sphere" and the current namespace were ":a:b", we would refer to the sphere as "c:sphere". Similarly, by setting the current namespace to be ":a:b:c" we could then refer directly to sphere in an operation such as a "setAttr", e.g.</p>
<p>setAttr sphere.translateX 10;</p>
<p>If relative mode is off, names are root-relative, thus we would need to refer to the sphere as follows. Note that when relative mode is off, Maya assumes the root namespace to base name lookups on:</p>
<p>setAttr a:b:c:sphere.translateX 10;</p>
<p>Also, we can always specify an absolute namepath (one that starts with a leading colon). An absolute namepath will work with relative name lookup enabled or disabled and is thus an easy way of referring to objects in a way that is name lookup-independent.</p>
<p>The relative mode feature is designed to allow users to write namespace-independent code which is intended to operate upon whatever namespace is current. The method <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#abcaaca6ccdbca180c9dc339c712eabbe" title="Get the name of the current namespace. ">MNamespace::currentNamespace()</a> allows you to query the name of the current namespace.</p>
<p>Relative mode can ge toggled using either <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a1670b257ba1372a5b68826966bf5d0ac" title="Set relative name lookup mode. ">MNamespace::setRelativeNames()</a> or the "namespace" command. Turning relative mode "off" causes name lookup to be based off the root namespace. Continuing our example where the current namespace is ":a:b" to refer to the sphere we would now need to use:</p>
<p>setAttr a:b:c:sphere.translateX 10;</p>
<p><b>Using namespaces with the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html" title="Namespace. ">MNamespace</a> class</b></p>
<p>Maya provides the "namespace" and "namespaceInfo" commands for dealing with namespaces from the command level, and there are also UI features which control and edit namespaces. All of these work harmoniously with the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html" title="Namespace. ">MNamespace</a> class.</p>
<p>It is important that any user code which exercises <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html" title="Namespace. ">MNamespace</a> methods that modify (rather than query) handle undo. For example, if writing a plug-in command that creates a new namespace, the plug-in needs to handle removal of the namespace on undo.</p>
<p>The <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html" title="Namespace. ">MNamespace</a> class contains methods to create and remove namespaces, set and query the current namespace, and edit and query the contents of namespaces.</p>
<p>To add individual objects to a namespace, use <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_selection_list.html#a23929aeafb29672f2652128eac9c4dec" title="Add the specified DG node to the end of the selection list. ">MSelectionList::add()</a> which is well suited for handling multiple objects having the same name as well as hierarchical namespaces. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa3506948f8769aa58fc34cee96172bdb"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#aa3506948f8769aa58fc34cee96172bdb">addNamespace</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;name, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> *parent=NULL)</td></tr>
<tr class="memdesc:aa3506948f8769aa58fc34cee96172bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the namespace `name'.  <a href="class_m_namespace.html#aa3506948f8769aa58fc34cee96172bdb">More...</a><br></td></tr>
<tr class="separator:aa3506948f8769aa58fc34cee96172bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a85d2eaf4ef2bf701cff29349a0c57"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a43a85d2eaf4ef2bf701cff29349a0c57">validateName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;name, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a43a85d2eaf4ef2bf701cff29349a0c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the specified name to a validated name which contains no illegal characters.  <a href="class_m_namespace.html#a43a85d2eaf4ef2bf701cff29349a0c57">More...</a><br></td></tr>
<tr class="separator:a43a85d2eaf4ef2bf701cff29349a0c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaaca6ccdbca180c9dc339c712eabbe"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#abcaaca6ccdbca180c9dc339c712eabbe">currentNamespace</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:abcaaca6ccdbca180c9dc339c712eabbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the current namespace.  <a href="class_m_namespace.html#abcaaca6ccdbca180c9dc339c712eabbe">More...</a><br></td></tr>
<tr class="separator:abcaaca6ccdbca180c9dc339c712eabbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af507c7c76183aa487aec60cd6836b011"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#af507c7c76183aa487aec60cd6836b011">setCurrentNamespace</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;name)</td></tr>
<tr class="memdesc:af507c7c76183aa487aec60cd6836b011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the specified namespace to be the current namespace.  <a href="class_m_namespace.html#af507c7c76183aa487aec60cd6836b011">More...</a><br></td></tr>
<tr class="separator:af507c7c76183aa487aec60cd6836b011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a00fe530ceeec7677c56ac3edad256"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a12a00fe530ceeec7677c56ac3edad256">getNamespaces</a> (const bool recurse=false, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a12a00fe530ceeec7677c56ac3edad256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of all namespaces in the current namespace.  <a href="class_m_namespace.html#a12a00fe530ceeec7677c56ac3edad256">More...</a><br></td></tr>
<tr class="separator:a12a00fe530ceeec7677c56ac3edad256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309cbe2753c5708b95547a4050f0de7d"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a309cbe2753c5708b95547a4050f0de7d">getNamespaces</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a559b12894616982e77379b6366da04f1">parentNamespace</a>, const bool recurse=false, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a309cbe2753c5708b95547a4050f0de7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of all child namespaces of `parentNamespace', with the option to list only direct children versus all descendents.  <a href="class_m_namespace.html#a309cbe2753c5708b95547a4050f0de7d">More...</a><br></td></tr>
<tr class="separator:a309cbe2753c5708b95547a4050f0de7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23e87bb294ef91ab2cdd51d69173c5b"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#ad23e87bb294ef91ab2cdd51d69173c5b">namespaceExists</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;name, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ad23e87bb294ef91ab2cdd51d69173c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given namespace exists.  <a href="class_m_namespace.html#ad23e87bb294ef91ab2cdd51d69173c5b">More...</a><br></td></tr>
<tr class="separator:ad23e87bb294ef91ab2cdd51d69173c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b12894616982e77379b6366da04f1"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a559b12894616982e77379b6366da04f1">parentNamespace</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a559b12894616982e77379b6366da04f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the current namespace's parent.  <a href="class_m_namespace.html#a559b12894616982e77379b6366da04f1">More...</a><br></td></tr>
<tr class="separator:a559b12894616982e77379b6366da04f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47fb9701e06353f390337e5c2dc5dc1"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#af47fb9701e06353f390337e5c2dc5dc1">removeNamespace</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;name, bool removeContents=false)</td></tr>
<tr class="memdesc:af47fb9701e06353f390337e5c2dc5dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified namespace.  <a href="class_m_namespace.html#af47fb9701e06353f390337e5c2dc5dc1">More...</a><br></td></tr>
<tr class="separator:af47fb9701e06353f390337e5c2dc5dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52081accd048c81ef04ab837df2aac4"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#aa52081accd048c81ef04ab837df2aac4">renameNamespace</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;oldName, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;newName, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> *parent=NULL)</td></tr>
<tr class="memdesc:aa52081accd048c81ef04ab837df2aac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename the specified namespace to a new name with optional parent name.  <a href="class_m_namespace.html#aa52081accd048c81ef04ab837df2aac4">More...</a><br></td></tr>
<tr class="separator:aa52081accd048c81ef04ab837df2aac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01b97eb34299f1e617d94f9bacd979d"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object_array.html">MObjectArray</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#aa01b97eb34299f1e617d94f9bacd979d">getNamespaceObjects</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a559b12894616982e77379b6366da04f1">parentNamespace</a>, const bool recurse=false, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:aa01b97eb34299f1e617d94f9bacd979d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of MObjects representing the object contained within the specified namespace.  <a href="class_m_namespace.html#aa01b97eb34299f1e617d94f9bacd979d">More...</a><br></td></tr>
<tr class="separator:aa01b97eb34299f1e617d94f9bacd979d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd934ef79180c570d286d9578b2b876"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#aafd934ef79180c570d286d9578b2b876">moveNamespace</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;src, const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;dst, const bool force=false)</td></tr>
<tr class="memdesc:aafd934ef79180c570d286d9578b2b876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the contents of the namespace `src' into the namespace `dst'.  <a href="class_m_namespace.html#aafd934ef79180c570d286d9578b2b876">More...</a><br></td></tr>
<tr class="separator:aafd934ef79180c570d286d9578b2b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0597d0ad8d92f20c9ab9718a2b54e5bb"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a0597d0ad8d92f20c9ab9718a2b54e5bb">rootNamespace</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a0597d0ad8d92f20c9ab9718a2b54e5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the root namespace.  <a href="class_m_namespace.html#a0597d0ad8d92f20c9ab9718a2b54e5bb">More...</a><br></td></tr>
<tr class="separator:a0597d0ad8d92f20c9ab9718a2b54e5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00316dc04eb382525f13bb395f38b2b9"><td class="memItemLeft" translate="no" align="right" valign="top">static bool&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a00316dc04eb382525f13bb395f38b2b9">relativeNames</a> (<a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a00316dc04eb382525f13bb395f38b2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query Maya's current "relative name lookup" state.  <a href="class_m_namespace.html#a00316dc04eb382525f13bb395f38b2b9">More...</a><br></td></tr>
<tr class="separator:a00316dc04eb382525f13bb395f38b2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1670b257ba1372a5b68826966bf5d0ac"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a1670b257ba1372a5b68826966bf5d0ac">setRelativeNames</a> (bool newState)</td></tr>
<tr class="memdesc:a1670b257ba1372a5b68826966bf5d0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set relative name lookup mode.  <a href="class_m_namespace.html#a1670b257ba1372a5b68826966bf5d0ac">More...</a><br></td></tr>
<tr class="separator:a1670b257ba1372a5b68826966bf5d0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9411b642d1e370138d52066e1cebbb"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a1c9411b642d1e370138d52066e1cebbb">getNamespaceFromName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;fullName, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a1c9411b642d1e370138d52066e1cebbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get namespace from a full name.  <a href="class_m_namespace.html#a1c9411b642d1e370138d52066e1cebbb">More...</a><br></td></tr>
<tr class="separator:a1c9411b642d1e370138d52066e1cebbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d06313c5ef9f98cc8feaef331cae7ec"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a3d06313c5ef9f98cc8feaef331cae7ec">stripNamespaceFromName</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;fullName, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:a3d06313c5ef9f98cc8feaef331cae7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the namespace from a full name.  <a href="class_m_namespace.html#a3d06313c5ef9f98cc8feaef331cae7ec">More...</a><br></td></tr>
<tr class="separator:a3d06313c5ef9f98cc8feaef331cae7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac856d8b8eccf45454b552137bf68b2e1"><td class="memItemLeft" translate="no" align="right" valign="top">static <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a>&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#ac856d8b8eccf45454b552137bf68b2e1">makeNamepathAbsolute</a> (const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;, <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *ReturnStatus=NULL)</td></tr>
<tr class="memdesc:ac856d8b8eccf45454b552137bf68b2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a namepath which is relative to the root into an absolute namepath.  <a href="class_m_namespace.html#ac856d8b8eccf45454b552137bf68b2e1">More...</a><br></td></tr>
<tr class="separator:ac856d8b8eccf45454b552137bf68b2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memItemLeft" translate="no" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" translate="no" valign="bottom"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">className</a> ()</td></tr>
<tr class="memdesc:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this class.  <a href="class_m_namespace.html#a774cd5d8fbebe8e7ed82a5aa587d1f04">More...</a><br></td></tr>
<tr class="separator:a774cd5d8fbebe8e7ed82a5aa587d1f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa3506948f8769aa58fc34cee96172bdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">OPENMAYA_MAJOR_NAMESPACE_OPEN <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> addNamespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the namespace `name'. </p>
<p>If the `parent' namespace is given the new namespace will be a child of `parent', otherwise the new namespace will be a child of the current namespace. The new namespace is added, but not made current. To make the new namespace be current use <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#af507c7c76183aa487aec60cd6836b011" title="Set the specified namespace to be the current namespace. ">MNamespace::setCurrentNamespace()</a>. Note that adding a namespace changes the scene, so any code that calls this method needs to handle undo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The new namespace to create. A qualified or unqualified name may be used. If a qualified name is used and one or more of the higher level namespaces do not already exist, they will be created automatically. For example, if the new name is "a:b:c" and "a" does not yet exist, then it will be created automatically and "b" automatically created beneath it and finally "c" will be created beneath "b". If the supplied name contains invalid characters it will first be modified as per the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a43a85d2eaf4ef2bf701cff29349a0c57" title="Convert the specified name to a validated name which contains no illegal characters. ">validateName()</a> method. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The fully qualified name of the namespace under which the new one is to be created. If not provided then the current namespace will be used. If the name of the new namespace is absolute (i.e. begins with a colon, ":a:b:c") then the 'parent' parameter will be ignored and the new namespace will be created under the root namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
<li><b>MS::kInvalidParameter</b> the given namespace already exists, the namespace name was invalid, or a non-existent parent namespace was specified. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a43a85d2eaf4ef2bf701cff29349a0c57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> validateName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the specified name to a validated name which contains no illegal characters. </p>
<p>The leading illegal characters will be removed and other illegal characters will be converted to '_'.</p>
<p>For example, name "@name@space@" will be converted to "name_space_".</p>
<p>If the entire name consists solely of illegal characters, e.g. "123" which contains only leading digits, then the returned string will be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the specified name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>optionally returns the status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successfully returned the validated name </li>
<li><b>MS::kFailure</b> internal error.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The validated name which contains no illegal characters. </dd></dl>
<dl class="section "><div id="dynsection-example0" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example0-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example0-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/scene_assembly_2assembly_reference_8cpp-example.html#a32">sceneAssembly/assemblyReference.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="abcaaca6ccdbca180c9dc339c712eabbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> currentNamespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the current namespace. </p>
<p>This name is returned as an absolute namepath (i.e. fully qualfied from the root namespace downwards, ":a:b:c").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>optionally returns the status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successfully returned the name of the current namespace. </li>
<li><b>MS::kFailure</b> internal error.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the current namespace as an absolute namepath. </dd></dl>

</div>
</div>
<a class="anchor" id="af507c7c76183aa487aec60cd6836b011"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> setCurrentNamespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the specified namespace to be the current namespace. </p>
<p>The `name' parameter you specify is relative to whatever namespace is current, but any namespace can be specified by passing an absolute name (e.g. :a:b:c). Note that making a namespace current changes the scene, so any code that calls this method needs to handle undo.</p>
<p>To make the root namespace become current, use:</p>
<p>status=MNamespace::setCurrentNamespace(MNamespace::rootNamespace());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the name of the namespace to make current.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
<li><b>MS::kInvalidParameter</b> `name' does not exist. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a12a00fe530ceeec7677c56ac3edad256"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> getNamespaces </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of all namespaces in the current namespace. </p>
<p>Notes: 1) Names returned are always absolute (e.g. :a:b:sphere). 2) The list returned is just the child namespaces (and descendents if `recurse' is true). It thus never contains the root namespace in the list returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recurse</td><td>optional parameter to control whether all namespaces or just top-level namespaces are returned. A value of false (the default if unspecified) causes only the top-level namespaces to be returned. If true, all namespaces will be listed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>optionally returns the status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of namespaces in the current namespace.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a309cbe2753c5708b95547a4050f0de7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html">MStringArray</a> getNamespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>parentNamespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of all child namespaces of `parentNamespace', with the option to list only direct children versus all descendents. </p>
<p>To list ALL namespaces in Maya, from the root downwards, specify the root namespace, i.e.:</p>
<p><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string_array.html" title="Array of MStrings data type. ">MStringArray</a> namespaces; namespaces = MNamepsace::getNamespaces( MNamespace::rootNamespace() );</p>
<p>Note: names returned are always absolute (e.g. :a:b:sphere).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parentNamespace</td><td>the namespace to query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recurse</td><td>optional parameter to control whether all descendents or just the direct children are returned. A value of false (the default if unspecified) causes only the direct children of `parentNamespace' to be listed. A value of true causes all descendent namespaces to be returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>optionally returns the status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of namespaces in the namespace specified via the 'namespacesToQuery' parameter.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
<li><b>MS::kInvalidParameter</b> `parentNamespace' does not exist. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad23e87bb294ef91ab2cdd51d69173c5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool namespaceExists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a given namespace exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the name of the namespace to search for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>optionally returns the status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><b>true</b> the namespace with the given name exists. </li>
<li><b>false</b> the namespace with the given name does not exist. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a559b12894616982e77379b6366da04f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> parentNamespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the current namespace's parent. </p>
<p>This name is returned as an absolute namepath (i.e. fully qualfied from the root namespace downwards, ":a:b"). If the root namespace is current, this method returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>optionally returns the status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successfully returned the name of the current namespace's parent. </li>
<li><b>MS::kFailure</b> the current namespace is the root namespace which has no parent.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the current namespace's parent as an absolute namepath. </dd></dl>

</div>
</div>
<a class="anchor" id="af47fb9701e06353f390337e5c2dc5dc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> removeNamespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeContents</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the specified namespace. </p>
<p>Note that removing a namespace changes the scene, so any code that calls this method needs to handle undo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>specifies the namespace to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">removeContents</td><td>detemine if remove contents of namespace</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
<li><b>MS::kInvalidParameter</b> the namespace was not found. </li>
<li><b>MS::kFailure</b> attempting to remove a system namespace, such as the root namespace, or if the namespace is non-empty. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa52081accd048c81ef04ab837df2aac4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> renameNamespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>oldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>newName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename the specified namespace to a new name with optional parent name. </p>
<p>Note that removing a namespace changes the scene, so any code that calls this method needs to handle undo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldName</td><td>the name of the namespace to rename. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newName</td><td>the new name for the namespace. If the supplied name contains invalid characters it will first be modified as per the <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a43a85d2eaf4ef2bf701cff29349a0c57" title="Convert the specified name to a validated name which contains no illegal characters. ">validateName()</a> method. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>optionally provides the name of the new parent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
<li><b>MS::kFailure</b> the given namespace already exists, the namespace name was invalid, e.g. "a:b" or it was not found or attempting to rename the root namespace. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example1" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example1-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example1-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/scene_assembly_2assembly_reference_8cpp-example.html#a34">sceneAssembly/assemblyReference.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="aa01b97eb34299f1e617d94f9bacd979d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object_array.html">MObjectArray</a> getNamespaceObjects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>parentNamespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recurse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array of MObjects representing the object contained within the specified namespace. </p>
<p>To query the current namespace, call this method in this way:</p>
<p><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_object_array.html" title="Array of MObjects data type. ">MObjectArray</a> objs; objs = MNamespace::getNamespaceObjects( MNamespace::currentNamespace() )</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parentNamespace</td><td>namepath of namespace to query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recurse</td><td>Optional parameter to control whether objects within all descendant namespaces should be returned, or only objects within the specified namespace `parentNamespace' should be returned. <br>
 False (the default if unspecified): only objects within `parentNamespace' are listed. <br>
 True: objects within all descendant namespaces are listed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>optionally returns the status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of objects that belong to the namespace specified by the 'parentNamespace' parameter. If the 'recurse' parameter was also specified as true, the list will contain the objects belonging to any child namespaces.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
<li><b>MS::kInvalidParameter</b> `name' was not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aafd934ef79180c570d286d9578b2b876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> moveNamespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move the contents of the namespace `src' into the namespace `dst'. </p>
<p>Note that moving namespace contents changes the scene, so any code that calls this method needs to handle undo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>source namespace from which objects will be moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>destination namespace to which objects will be moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>optional parameter which if true forces the move even if name clashes occur, in which case nodes are renamed to ensure uniqueness. If false, the move will not happen if there are clashes. The default value is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return status code.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
<li><b>MS::kInvalidParameter</b> the namespace `src' and/or `dst' does not exist. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0597d0ad8d92f20c9ab9718a2b54e5bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> rootNamespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the root namespace. </p>
<p>This name is an absolute namepath (i.e. prefixed by a ":"). An example use of this method would be to set the current namespace to the root namespace, and this could be done as follows:</p>
<p>status=MNamespace::setCurrentNamespace(MNamespace::rootNamespace());</p>
<p>Another example would be to test if the current namespace is the root, e.g.</p>
<p>if ( <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#abcaaca6ccdbca180c9dc339c712eabbe" title="Get the name of the current namespace. ">MNamespace::currentNamespace()</a> == <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a0597d0ad8d92f20c9ab9718a2b54e5bb" title="Get the name of the root namespace. ">MNamespace::rootNamespace()</a> ) {</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>optionally returns the status code from the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> Successfully returned the name of the root namespace.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the root namespace as an absolute namepath. </dd></dl>

</div>
</div>
<a class="anchor" id="a00316dc04eb382525f13bb395f38b2b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">bool relativeNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query Maya's current "relative name lookup" state. </p>
<p>Relative name lookup causes lookups to be relative to the current namespace. By default, relative name lookup in Maya is off, which causes name lookups to be relative to the root namespace. For example, if you have the object :a:b:sphere, and the current namespace is ":a:b", in relative name lookup mode you can issue a command like</p>
<p>setAttr sphere.translateX 10;</p>
<p>If relative name lookup is off, you need to specify the full namepath, e.g.</p>
<p>setAttr a:b:sphere.translateX 10;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>returns the status of the query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if relatve name lookup is on, false otherwise.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1670b257ba1372a5b68826966bf5d0ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> setRelativeNames </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set relative name lookup mode. </p>
<p>Note that turning on or off relativeNames mode can change the scene, so any code that calls this method needs to handle undo. See <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_namespace.html#a00316dc04eb382525f13bb395f38b2b9" title="Query Maya&#39;s current &quot;relative name lookup&quot; state. ">MNamespace::relativeNames()</a> for details on relative name lookup.</p>
<p>Note: relative name lookup mode is intended for bracketing user code which needs to be namespace-independent. Leaving relative name lookup enabled outside of your specific code could cause functionality such as 3rd-party plugins that assume absolute name lookup to fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newState</td><td>true to turn on relative name lookup, false to turn it off. Maya's default setting is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status code from the operation.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successfully set the relativeNames value. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1c9411b642d1e370138d52066e1cebbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> getNamespaceFromName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>fullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get namespace from a full name. </p>
<p>For example, given a full name: "a:b:c:d:ball" this method would return: "a:b:c:d".</p>
<p>NOTE: there is no testing to ensure that the name actually refers to an object that exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fullName</td><td>the full name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>returns the status of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the namespace from the full name.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> found the namespace. </li>
<li><b>MS::kFailure</b> fullName parameter had length of zero. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3d06313c5ef9f98cc8feaef331cae7ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> stripNamespaceFromName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>fullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strips the namespace from a full name. </p>
<p>For example, given a full name: "a:b:c:d:ball" this method would return: "ball".</p>
<p>NOTE: there is no testing to ensure that the name actually refers to an object that exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fullName</td><td>the full name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>returns the status of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the name part of a full name.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> found the namespace. </li>
<li><b>MS::kFailure</b> fullName parameter had length of zero. </li>
</ul>
</dd></dl>
<dl class="section "><div id="dynsection-example2" class="dynheader closed" onclick="return toggleVisibility(this)" style="cursor:pointer;"><dt><img id="dynsection-example2-trigger" src="cpp_ref/closed.png" alt="+"> <b>Examples: </b></dt></div><div id="dynsection-example2-content" class="dyncontent" style="display:none;"><dd><a class="el" translate="no" href="#!/url=./cpp_ref/lep_translator_2lep_translator_8cpp-example.html#a35">lepTranslator/lepTranslator.cpp</a>.</dd></div>
</dl>
</div>
</div>
<a class="anchor" id="ac856d8b8eccf45454b552137bf68b2e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> makeNamepathAbsolute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" translate="no" href="#!/url=./cpp_ref/class_m_string.html">MString</a> &amp;&#160;</td>
          <td class="paramname"><em>namepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" translate="no" href="#!/url=./cpp_ref/class_m_status.html">MStatus</a> *&#160;</td>
          <td class="paramname"><em>ReturnStatus</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a namepath which is relative to the root into an absolute namepath. </p>
<p>For example, given the namepath "a:sphere" this method returns ":a:sphere". It also culls out duplicate and trailing separators, e.g. "a:b::c:" will return ":a:b:c".</p>
<p>NOTE: there is no testing to ensure that the name actually refers to an object that exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">namepath</td><td>the root-relative namepath. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ReturnStatus</td><td>returns the status of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute namepath.</dd></dl>
<dl class="section user"><dt>Status Codes:</dt><dd><ul>
<li><b>MS::kSuccess</b> successful execution. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a774cd5d8fbebe8e7ed82a5aa587d1f04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname" translate="no">const char * className </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class. </dd></dl>

</div>
</div>
<hr>The documentation for this class was generated from the following files:<ul>
<li>MNamespace.h</li>
<li>MNamespace.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
          <div class="footer-block"><a href="../html/ac.cmtdialog.htm" class="comments-anchor" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
   </div></body>
</html>
