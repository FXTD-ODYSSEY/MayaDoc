<!-- saved from url=(0024)http://docs.autodesk.com -->


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PyNodes &mdash; PyMEL 1.0.9 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css">
  

  
    <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css">
  

  
    <link rel="top" title="PyMEL 1.0.9 documentation" href="index.html">
        <link rel="next" title="Attributes" href="attributes.html">
        <link rel="prev" title="Getting Started" href="tutorial.html"> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PyMEL
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs">
    <input type="hidden" name="check_keywords" value="yes">
    <input type="hidden" name="area" value="default">
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="whats_new.html">What&#8217;s New</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="why_pymel.html">Why PyMEL?</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">PyNodes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#api-underpinnings">API Underpinnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pynodes-are-not-strings">PyNodes Are Not Strings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#node-renaming">Node Renaming</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#node-class-hierarchy">Node Class Hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#chained-function-and-attribute-lookups">Chained Function and Attribute Lookups</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-pynodes-as-keys-in-dictionaries">Using PyNodes as Keys in Dictionaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mommy-where-do-pynodes-come-from">Mommy, Where Do PyNodes Come From?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mel-node-commands-and-their-pynode-counterparts">MEL Node Commands and their PyNode Counterparts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api-classes-and-their-pynode-counterparts">API Classes and their PyNode Counterparts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#glossary">Glossary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="attributes.html">Attributes</a></li>
<li class="toctree-l1"><a class="reference internal" href="non_existent_objs.html">Non-Existent Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="ui.html">Building User Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="standalone.html">Standalone Maya Python Interpreter</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="eclipse.html">Setting Up PyMEL Autocompletion in Eclipse</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html">For Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">Design Philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="mel_to_python.html">MEL to Python Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Module Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyMEL</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>PyNodes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/pynodes.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pynodes">
<h1>PyNodes<a class="headerlink" href="#pynodes" title="Permalink to this headline">¶</a></h1>
<p>The pymel module reorganizes many of the most commonly used mel commands and API methods into a
hierarchy of classes. This design allows you to write much more concise and readable python code. It also helps
keep all of the commands organized, so that functions are paired only with the types of objects that can use them.</p>
<p>The <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode" title="pymel.core.general.PyNode"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode</span></tt></a> class is the base object for all node-, component-, and attribute-related classes. We collectively refer
to all these classes as &#8220;PyNodes&#8221;.</p>
<p>In order to use the object-oriented design of pymel, you must ensure that the objects that you are working
with are instances of PyMEL classes. To make this easier, PyMEL contains wrapped version
of the more common commands for creating and getting lists of objects. These modified commands cast their results to the appropriate
<a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode" title="pymel.core.general.PyNode"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode</span></tt></a> class type. See <a class="reference internal" href="generated/functions/pymel.core.general/pymel.core.general.ls.html#pymel.core.general.ls" title="pymel.core.general.ls"><tt class="xref py py-obj docutils literal"><span class="pre">ls</span></tt></a>, <a class="reference internal" href="generated/functions/pymel.core.general/pymel.core.general.listRelatives.html#pymel.core.general.listRelatives" title="pymel.core.general.listRelatives"><tt class="xref py py-obj docutils literal"><span class="pre">listRelatives</span></tt></a>, <a class="reference internal" href="generated/functions/pymel.core.general/pymel.core.general.listTransforms.html#pymel.core.general.listTransforms" title="pymel.core.general.listTransforms"><tt class="xref py py-obj docutils literal"><span class="pre">listTransforms</span></tt></a>, <a class="reference internal" href="generated/functions/pymel.core.general/pymel.core.general.selected.html#pymel.core.general.selected" title="pymel.core.general.selected"><tt class="xref py py-obj docutils literal"><span class="pre">selected</span></tt></a>, and <a class="reference internal" href="generated/functions/pymel.core.general/pymel.core.general.listHistory.html#pymel.core.general.listHistory" title="pymel.core.general.listHistory"><tt class="xref py py-obj docutils literal"><span class="pre">listHistory</span></tt></a>, for a few examples.</p>
<dl class="docutils">
<dt>Commands that list objects return PyMEL classes:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;transform&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">&lt;class &#39;pymel.core.nodetypes.Transform&#39;&gt;</span>
</pre></div>
</div>
</dd>
<dt>Commands that create objects are wrapped as well:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">polySphere</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">pSphere1 &lt;class &#39;pymel.core.nodetypes.Transform&#39;&gt;</span>
</pre></div>
</div>
</dd>
</dl>
<div class="section" id="api-underpinnings">
<h2>API Underpinnings<a class="headerlink" href="#api-underpinnings" title="Permalink to this headline">¶</a></h2>
<p>In MEL, the best representation we have have of a maya node or attribute is its name.  But with the API we can do better!  When creating an instance of a <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode" title="pymel.core.general.PyNode"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode</span></tt></a> class, PyMEL determines the underlying API object behind the scenes. With this in hand, it can operate on the object itself, not just the string representing the object.</p>
<p>So, what does this mean to you?  Well, let&#8217;s take a common example: testing if two nodes or attributes are the
same. In MEL, to accomplish this the typical solution is to perform a string comparison of two object names, but there are many ways that this seemingly simple operation can go wrong. For instance, forgetting to compare the full paths of dag node objects, or comparing the long name of an attribute to the short name of an attribute.  And what if you want to test if the nodes are instances of each other?  You&#8217;ll have some pretty nasty string processing ahead of you.  And if someone renames the node or its name becomes non-unique after you&#8217;ve already gotten its name as a string then your script will fail.  With PyMEL, the nightmares of string comparisons are over.</p>
<p>Since PyMEL uses the underlying API objects, these operations are simple and API-fast.</p>
<p>In this example, we&#8217;ll make a sphere, group it, then instance the group, so that we have a tricky situation with instances and non-unique names.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymel.core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Make two instanced spheres in different groups</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere1</span><span class="p">,</span> <span class="n">hist</span> <span class="o">=</span> <span class="n">polySphere</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mySphere&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grp</span> <span class="o">=</span> <span class="n">group</span><span class="p">(</span><span class="n">sphere1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grp2</span> <span class="o">=</span> <span class="n">instance</span><span class="p">(</span><span class="n">grp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere2</span> <span class="o">=</span> <span class="n">grp2</span><span class="o">.</span><span class="n">getChildren</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Now lets take a look at our objects and see how our various comparisons turn out.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># check out our objects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere1</span>                            <span class="c1"># the original</span>
<span class="go">Transform(u&#39;group1|mySphere&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere2</span>                            <span class="c1"># the instance</span>
<span class="go">Transform(u&#39;group2|mySphere&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># do some tests</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># they aren&#39;t the same dag objects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere1</span> <span class="o">==</span> <span class="n">sphere2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but they are instances of each other</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere1</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="p">(</span> <span class="n">sphere2</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Attribute comparison is simple, too. Keep in mind, we are not comparing the values of the attributes &#8211; for that we would need to use the <tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt> method &#8211; we are comparing the attributes themselves.  This is more flexible and reliable than comparing names:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># long and short names retrieve the same attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere1</span><span class="o">.</span><span class="n">t</span> <span class="o">==</span> <span class="n">sphere1</span><span class="o">.</span><span class="n">translate</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere1</span><span class="o">.</span><span class="n">tx</span> <span class="o">==</span> <span class="n">sphere1</span><span class="o">.</span><span class="n">translate</span><span class="o">.</span><span class="n">translateX</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the same attrs on different nodes/instances are still the same</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sphere1</span><span class="o">.</span><span class="n">t</span> <span class="o">==</span> <span class="n">sphere2</span><span class="o">.</span><span class="n">t</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And here&#8217;s an incredibly useful feature that I get asked for all the time.  Get all the instances of an object in a scene:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>    &gt;&gt;&gt; sphere1.getInstances()
[Transform(u&#39;group1|mySphere&#39;), Transform(u&#39;group2|mySphere&#39;)]
    &gt;&gt;&gt; sphere1.getOtherInstances()
[Transform(u&#39;group2|mySphere&#39;)]
</pre></div>
</div>
<p>For more on the relationship between PyMEL and Maya&#8217;s API, see <a class="reference internal" href="#api-pynodes"><em>API Classes and their PyNode Counterparts</em></a>.</p>
</div>
<div class="section" id="pynodes-are-not-strings">
<span id="pynodes-not-strings"></span><h2>PyNodes Are Not Strings<a class="headerlink" href="#pynodes-are-not-strings" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode" title="pymel.core.general.PyNode"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode</span></tt></a> base class inherits from <a class="reference internal" href="generated/classes/pymel.util.utilitytypes/pymel.util.utilitytypes.ProxyUnicode.html#pymel.util.utilitytypes.ProxyUnicode" title="pymel.util.utilitytypes.ProxyUnicode"><tt class="xref py py-obj docutils literal"><span class="pre">ProxyUnicode</span></tt></a> class, which has the functionality of a string object, but removes the immutability restriction.  It is important to keep in mind that although PyNodes <em>behave</em> like strings in most situations, they are not actual strings. Functions which explicitly require a string, might raise an error. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">objs</span> <span class="o">=</span> <span class="n">ls</span><span class="p">(</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;camera&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="n">objs</span> <span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">sequence item 0: expected string, Camera found</span>
</pre></div>
</div>
<p>The solution is simple: convert the PyNodes to strings.  The following example uses a shorthand python expression called &#8220;list comprehension&#8221; to convert the list of PyNodes to a list of strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">objs</span> <span class="o">=</span> <span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;camera&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">objs</span> <span class="p">])</span>
<span class="go">&#39;frontShape, perspShape, sideShape, topShape&#39;</span>
</pre></div>
</div>
<p>Similarly, if you are trying to concatenate your PyNode with another string, you will need to cast it to a string (same as you would have
to do with an int):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s2">&quot;Camera 1 of &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objs</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; is named &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">objs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">Camera 1 of 4 is named frontShape</span>
</pre></div>
</div>
<p>Alternately, you can use string formatting syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s2">&quot;Camera 1 of </span><span class="si">%s</span><span class="s2"> is named </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">objs</span><span class="p">),</span> <span class="n">objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
<span class="go">Camera 1 of 4 is named frontShape</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">%s</span></tt> means to format as a string.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>You can get more control over how numbers are formatted by using <tt class="docutils literal"><span class="pre">%f</span></tt> for floats and <tt class="docutils literal"><span class="pre">%d</span></tt> for integers:</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;You can control precision </span><span class="si">%.02f</span><span class="s2"> and padding </span><span class="si">%04d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="mf">1.2345</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
<span class="go">&#39;You can control precision 1.23 and padding 0002&#39;</span>
</pre></div>
</div>
</div>
<p>By default, the shortest unique name of the node is used when converting to a string. If you want more control over how the name is printed, use the various methods for retrieving the name as a string:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span><span class="o">.</span><span class="n">shortName</span><span class="p">()</span> <span class="c1"># shortest unique</span>
<span class="go">u&#39;frontShape&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span><span class="o">.</span><span class="n">nodeName</span><span class="p">()</span> <span class="c1"># just the node, same as unique in this case</span>
<span class="go">u&#39;frontShape&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span><span class="o">.</span><span class="n">longName</span><span class="p">()</span> <span class="c1"># full dag path</span>
<span class="go">u&#39;|front|frontShape&#39;</span>
</pre></div>
</div>
<p>Finally, be aware that string operations with PyNodes return strings not new PyNodes:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;front&#39;</span><span class="p">,</span> <span class="s1">&#39;monkey&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">new</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>
<span class="go">monkeyShape &lt;type &#39;unicode&#39;&gt; &lt;class &#39;pymel.core.nodetypes.Camera&#39;&gt;</span>
</pre></div>
</div>
<div class="section" id="node-renaming">
<h3>Node Renaming<a class="headerlink" href="#node-renaming" title="Permalink to this headline">¶</a></h3>
<p>Maya nodes can be renamed, which means that each time the name of the node is required &#8211; such as printing, slicing, splitting, or passing to any command derived from <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> &#8211; the object&#8217;s current name is queried from the underlying API object. This ensures renames performed via mel or the UI will always be reflected in the name returned by your PyNode class and your variables will remain valid despite these changes.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">orig</span> <span class="o">=</span> <span class="n">polyCube</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;myCube&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">orig</span>                    <span class="c1"># print out the starting name</span>
<span class="go">myCube</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orig</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;crazyCube&#39;</span><span class="p">)</span>      <span class="c1"># rename it (the new name is returned)</span>
<span class="go">Transform(u&#39;crazyCube&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">orig</span>                    <span class="c1"># the variable &#39;orig&#39; reflects the name change</span>
<span class="go">crazyCube</span>
</pre></div>
</div>
<p>As you can see, you do not need to assign the result of a rename to a variable, although, for backward compatibility&#8217;s sake, we&#8217;ve ensured that you still can.</p>
<p>Querying the name of the object is not infinitely fast, so try to avoid doing it repetitively, if possible.</p>
<p>See <a class="reference internal" href="#pynodes-in-dicts"><em>Using PyNodes as Keys in Dictionaries</em></a> for more information on PyNode mutability.</p>
</div>
</div>
<div class="section" id="node-class-hierarchy">
<h2>Node Class Hierarchy<a class="headerlink" href="#node-class-hierarchy" title="Permalink to this headline">¶</a></h2>
<p>PyMEL provides a class for every node type in Maya&#8217;s type hierarchy.  The name of the class is the node type capitalized.  Wherever possible,
PyMEL functions will return objects as instances of these classes. This allows you to use built-in python functions to inspect
and compare your objects.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dl</span> <span class="o">=</span> <span class="n">directionalLight</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span>
<span class="go">&lt;class &#39;pymel.core.nodetypes.DirectionalLight&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span> <span class="n">dl</span><span class="p">,</span> <span class="n">nodetypes</span><span class="o">.</span><span class="n">DirectionalLight</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span> <span class="n">dl</span><span class="p">,</span> <span class="n">nodetypes</span><span class="o">.</span><span class="n">Light</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span> <span class="n">dl</span><span class="p">,</span> <span class="n">nodetypes</span><span class="o">.</span><span class="n">Shape</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span> <span class="n">dl</span><span class="p">,</span> <span class="n">nodetypes</span><span class="o">.</span><span class="n">DagNode</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span> <span class="n">dl</span><span class="p">,</span> <span class="n">nodetypes</span><span class="o">.</span><span class="n">Mesh</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Many of these classes contain no methods of their own and exist only as place-holders in the hierarchy.
However, there are certain key classes which provide important methods to all their sub-classes. A few of the more important
include <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.DependNode.html#pymel.core.nodetypes.DependNode" title="pymel.core.nodetypes.DependNode"><tt class="xref py py-obj docutils literal"><span class="pre">nt.DependNode</span></tt></a>, <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.DagNode.html#pymel.core.nodetypes.DagNode" title="pymel.core.nodetypes.DagNode"><tt class="xref py py-obj docutils literal"><span class="pre">nt.DagNode</span></tt></a>, <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.Transform.html#pymel.core.nodetypes.Transform" title="pymel.core.nodetypes.Transform"><tt class="xref py py-obj docutils literal"><span class="pre">nt.Transform</span></tt></a>, and <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.Constraint.html#pymel.core.nodetypes.Constraint" title="pymel.core.nodetypes.Constraint"><tt class="xref py py-obj docutils literal"><span class="pre">nt.Constraint</span></tt></a>.</p>
</div>
<div class="section" id="chained-function-and-attribute-lookups">
<h2>Chained Function and Attribute Lookups<a class="headerlink" href="#chained-function-and-attribute-lookups" title="Permalink to this headline">¶</a></h2>
<p>Mel provides the versatility of operating on a shape node via its transform node.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>camera -q -centerOfInterest persp
camera -q -centerOfInterest perspShape
</pre></div>
</div>
<p>PyMEL achieves this effect by chaining function lookups.  If a called method does not exist on the <tt class="xref py py-obj docutils literal"><span class="pre">Transform</span></tt> class, the
request will be passed to appropriate class of the transform&#8217;s shape node, if it exists.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get the persp camera as a PyNode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trans</span> <span class="o">=</span> <span class="n">PyNode</span><span class="p">(</span><span class="s1">&#39;persp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get the transform&#39;s shape, aka the camera node</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">getShape</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">cam</span>
<span class="go">perspShape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trans</span><span class="o">.</span><span class="n">getCenterOfInterest</span><span class="p">()</span>
<span class="go">44.82186966202994</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span><span class="o">.</span><span class="n">getCenterOfInterest</span><span class="p">()</span>
<span class="go">44.82186966202994</span>
</pre></div>
</div>
<p>Technically speaking, the Transform does not have a <tt class="xref py py-obj docutils literal"><span class="pre">getCenterOfInterest</span></tt> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trans</span><span class="o">.</span><span class="n">getCenterOfInterest</span>
<span class="go">&lt;bound method Camera.getCenterOfInterest of Camera(u&#39;perspShape&#39;)&gt;</span>
</pre></div>
</div>
<p>Notice the bound method belongs to the <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.Camera.html#pymel.core.nodetypes.Camera" title="pymel.core.nodetypes.Camera"><tt class="xref py py-obj docutils literal"><span class="pre">nt.Camera</span></tt></a> class.</p>
</div>
<div class="section" id="using-pynodes-as-keys-in-dictionaries">
<span id="pynodes-in-dicts"></span><h2>Using PyNodes as Keys in Dictionaries<a class="headerlink" href="#using-pynodes-as-keys-in-dictionaries" title="Permalink to this headline">¶</a></h2>
<p>A powerful feature was added in Maya 2009 that gives us access to a unique id per node. You can access this by
using the special method <tt class="xref py py-obj docutils literal"><span class="pre">nt.DependNode.__hash__</span></tt>, though typically you won&#8217;t need to use this directly.  Its existence means that PyNodes can be used as a key in a dictionary in a name-independent way: if the name of the node changes, the PyNode object can still be used to retrieve data placed in the dictionary prior to the name change.  It is important to note, however, that this id is only valid while the scene is open. Once it is closed and reopened, the id for each node will change.</p>
<p>Below is an example demonstrating how this feature allows us to create a dictionary of node-to-name mappings, which could be used to track changes to a file.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">AllObjects</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># node-to-name dictionary</span>
<span class="k">def</span> <span class="nf">store</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">():</span>
        <span class="n">AllObjects</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">diff</span><span class="p">():</span>
    <span class="n">AllObjsCopy</span> <span class="o">=</span> <span class="n">AllObjects</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">oldName</span> <span class="o">=</span> <span class="n">AllObjsCopy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="n">newName</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">newName</span> <span class="o">!=</span> <span class="n">oldName</span><span class="p">:</span>
                <span class="k">print</span> <span class="s2">&quot;renamed: </span><span class="si">%s</span><span class="s2"> ---&gt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">oldName</span><span class="p">,</span> <span class="n">newName</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
           <span class="k">print</span> <span class="s2">&quot;new: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">obj</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">AllObjsCopy</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">print</span> <span class="s2">&quot;deleted:&quot;</span><span class="p">,</span> <span class="n">name</span>
</pre></div>
</div>
<p>create some objects and store them to start:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">polyCube</span><span class="p">(</span><span class="n">ch</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">store</span><span class="p">()</span>  <span class="c1"># save the state of the current scene</span>
</pre></div>
</div>
<p>now make some changes:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;monkey&#39;</span><span class="p">)</span>
<span class="n">delete</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">getShape</span><span class="p">())</span>
<span class="n">polyTorus</span><span class="p">()</span>
</pre></div>
</div>
<p>print out what&#8217;s changed since we ran <tt class="docutils literal"><span class="pre">store()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">diff</span><span class="p">()</span>
</pre></div>
</div>
<p>this prints out:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>renamed: nurbsSphere1 ---&gt; monkey
renamed: nurbsSphereShape1 ---&gt; monkeyShape
new: polyTorus1
new: pTorus1
new: pTorusShape1
deleted: pCubeShape1
</pre></div>
</div>
</div>
<div class="section" id="mommy-where-do-pynodes-come-from">
<h2>Mommy, Where Do PyNodes Come From?<a class="headerlink" href="#mommy-where-do-pynodes-come-from" title="Permalink to this headline">¶</a></h2>
<p>In order to understand PyNode classes, it&#8217;s best to understand their relationship to the underlying objects that they wrap. The methods on each node class are derived from three sources:</p>
<ol class="arabic simple">
<li>automatically, from maya.cmds</li>
<li>automatically, from maya.OpenMaya*</li>
<li>manually, written by PyMEL team</li>
</ol>
<div class="section" id="mel-node-commands-and-their-pynode-counterparts">
<span id="mel-pynodes"></span><h3>MEL Node Commands and their PyNode Counterparts<a class="headerlink" href="#mel-node-commands-and-their-pynode-counterparts" title="Permalink to this headline">¶</a></h3>
<p>As you are probably aware, MEL contains a number of commands
which are used to create, edit, and query object types in maya.  Typically, the names of these commands correspond
with the node type on which they operate. However, it should be noted
that there are a handful of exceptions to this rule.</p>
<p>Some examples of command-class pairs.  Notice that the last two nodes do not match their corresponding command:</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%">
<col width="33%">
<col width="35%">
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Mel Command</th>
<th class="head">Maya Node Type</th>
<th class="head">PyMEL Node  Class</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>aimConstraint</td>
<td>aimConstraint</td>
<td>AimConstraint</td>
</tr>
<tr class="row-odd"><td>camera</td>
<td>camera</td>
<td>Camera</td>
</tr>
<tr class="row-even"><td>directionalLight</td>
<td>directionalLight</td>
<td>DirectionalLight</td>
</tr>
<tr class="row-odd"><td>spaceLocator</td>
<td>locator</td>
<td>Locator</td>
</tr>
<tr class="row-even"><td>vortex</td>
<td>vortexField</td>
<td>VortexField</td>
</tr>
</tbody>
</table>
<p>This example demonstrates some basic principles. Note the relationship between the name of the object
created, its node type, and its class type. Also notice that instead of creating new objects using
maya.cmds functions ( ex. <a class="reference internal" href="generated/functions/pymel.core.rendering/pymel.core.rendering.spotLight.html#pymel.core.rendering.spotLight" title="pymel.core.rendering.spotLight"><tt class="xref py py-obj docutils literal"><span class="pre">spotlight</span></tt></a> ), the class ( ex. <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.SpotLight.html#pymel.core.nodetypes.SpotLight" title="pymel.core.nodetypes.SpotLight"><tt class="xref py py-obj docutils literal"><span class="pre">nt.SpotLight</span></tt></a> ) can also be used :</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pymel.core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">nodetypes</span><span class="o">.</span><span class="n">SpotLight</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s2">&quot;The name is&quot;</span><span class="p">,</span> <span class="n">l</span>
<span class="go">The name is spotLightShape1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s2">&quot;The maya type is&quot;</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">The maya type is spotLight</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s2">&quot;The python type is&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">The python type is &lt;class &#39;pymel.core.nodetypes.SpotLight&#39;&gt;</span>
</pre></div>
</div>
<p>Once you have an instance of a PyMEL class, you can use it to query and edit the
maya node it represents in an object-oriented way.</p>
<p>Make the light red and get shadow samples, the old, procedural way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">spotLight</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">edit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rgb</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">spotLight</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shadowSamples</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Now, the object-oriented, PyMEL way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="o">.</span><span class="n">setRgb</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">l</span><span class="o">.</span><span class="n">getShadowSamples</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>For those familiar with MEL, you can probably already tell that the DirectionalLight class can be understood as an
object-oriented reorganization of the directionalLight command, where you &#8216;get&#8217; queries and you &#8216;set&#8217; edits.</p>
<p>Some classes have functionality that goes beyond their command counterpart. The <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.Camera.html#pymel.core.nodetypes.Camera" title="pymel.core.nodetypes.Camera"><tt class="xref py py-obj docutils literal"><span class="pre">nt.Camera</span></tt></a> class,
for instance, also contains the abilities of the <a class="reference internal" href="generated/functions/pymel.core.rendering/pymel.core.rendering.track.html#pymel.core.rendering.track" title="pymel.core.rendering.track"><tt class="xref py py-obj docutils literal"><span class="pre">track</span></tt></a>, <a class="reference internal" href="generated/functions/pymel.core.rendering/pymel.core.rendering.orbit.html#pymel.core.rendering.orbit" title="pymel.core.rendering.orbit"><tt class="xref py py-obj docutils literal"><span class="pre">orbit</span></tt></a>, <a class="reference internal" href="generated/functions/pymel.core.rendering/pymel.core.rendering.dolly.html#pymel.core.rendering.dolly" title="pymel.core.rendering.dolly"><tt class="xref py py-obj docutils literal"><span class="pre">dolly</span></tt></a>, and <a class="reference internal" href="generated/functions/pymel.core.rendering/pymel.core.rendering.cameraView.html#pymel.core.rendering.cameraView" title="pymel.core.rendering.cameraView"><tt class="xref py py-obj docutils literal"><span class="pre">cameraView</span></tt></a> commands:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span> <span class="o">=</span> <span class="n">nodetypes</span><span class="o">.</span><span class="n">Camera</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;newCam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span><span class="o">.</span><span class="n">setFocalLength</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span><span class="o">.</span><span class="n">getHorizontalFieldOfView</span><span class="p">()</span>
<span class="go">20.407947443463367</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span><span class="o">.</span><span class="n">dolly</span><span class="p">(</span><span class="n">distance</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span><span class="o">.</span><span class="n">track</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span><span class="o">.</span><span class="n">addBookmark</span><span class="p">(</span><span class="s1">&#39;new&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="api-classes-and-their-pynode-counterparts">
<span id="api-pynodes"></span><h3>API Classes and their PyNode Counterparts<a class="headerlink" href="#api-classes-and-their-pynode-counterparts" title="Permalink to this headline">¶</a></h3>
<p>PyNode classes derive their methods from both MEL and the API ( aka. maya.cmds and maya.OpenMaya, respectively ).  If you&#8217;re familiar with Maya&#8217;s API, you know that there is a distinct separation between objects and their abilities.  There are fundamental object types such as <tt class="docutils literal"><span class="pre">maya.OpenMaya.MObject</span></tt> and <tt class="docutils literal"><span class="pre">maya.OpenMaya.MDagPath</span></tt> that represent the object itself, and there are &#8220;function sets&#8221;, which are classes that,
once instantiated with a given fundamental object, provide it with special abilities.  ( Because I am a huge nerd, I like to the think of the function sets as robotic &#8220;mechs&#8221; and the fundamental objects as &#8220;spirits&#8221; or &#8220;ghosts&#8221; that inhabit them, like in <em>Ghost in the Shell</em> ).</p>
<p>For simplicity, PyMEL does away with this distinction: a PyNode instance is the equivalent of an activated API function set;  the necessary fundamental API objects are determined behind the scenes at instantiation.  You can access these by using the special methods <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.DependNode.html#pymel.core.nodetypes.DependNode.__apimobject__" title="pymel.core.nodetypes.DependNode.__apimobject__"><tt class="xref py py-obj docutils literal"><span class="pre">nt.DependNode.__apimobject__</span></tt></a>, <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.Attribute.html#pymel.core.general.Attribute.__apimobject__" title="pymel.core.general.Attribute.__apimobject__"><tt class="xref py py-obj docutils literal"><span class="pre">Attribute.__apimobject__</span></tt></a>, <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.DependNode.html#pymel.core.nodetypes.DependNode.__apihandle__" title="pymel.core.nodetypes.DependNode.__apihandle__"><tt class="xref py py-obj docutils literal"><span class="pre">nt.DependNode.__apihandle__</span></tt></a>, <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.DagNode.html#pymel.core.nodetypes.DagNode.__apimdagpath__" title="pymel.core.nodetypes.DagNode.__apimdagpath__"><tt class="xref py py-obj docutils literal"><span class="pre">nt.DagNode.__apimdagpath__</span></tt></a>, <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.Attribute.html#pymel.core.general.Attribute.__apimdagpath__" title="pymel.core.general.Attribute.__apimdagpath__"><tt class="xref py py-obj docutils literal"><span class="pre">Attribute.__apimdagpath__</span></tt></a>, <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.Attribute.html#pymel.core.general.Attribute.__apimplug__" title="pymel.core.general.Attribute.__apimplug__"><tt class="xref py py-obj docutils literal"><span class="pre">Attribute.__apimplug__</span></tt></a>, and <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode.__apimfn__" title="pymel.core.general.PyNode.__apimfn__"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode.__apimfn__</span></tt></a>.  (Be aware that this is still considered internal magic, and the names of these methods are subject to change ):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PyNode</span><span class="p">(</span><span class="s1">&#39;perspShape&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">__apimfn__</span><span class="p">()</span> 
<span class="go">&lt;maya.OpenMaya.MFnCamera; proxy of &lt;Swig Object of type &#39;MFnCamera *&#39; at ...&gt; &gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">__apimdagpath__</span><span class="p">()</span> 
<span class="go">&lt;maya.OpenMaya.MDagPath; proxy of &lt;Swig Object of type &#39;MDagPath *&#39; at ...&gt; &gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">focalLength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">Attribute(u&#39;perspShape.focalLength&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">__apimplug__</span><span class="p">()</span> 
<span class="go">&lt;maya.OpenMaya.MPlug; proxy of &lt;Swig Object of type &#39;MPlug *&#39; at ...&gt; &gt;</span>
</pre></div>
</div>
<p>As you can probably see, these methods are enormously useful when prototyping API plugins.  Also of great use is the <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode" title="pymel.core.general.PyNode"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode</span></tt></a> class, which can be instantiated using API objects.</p>
</div>
</div>
<div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="glossary docutils">
<dt id="term-mutable"><span id="term-mutability-describes-a-data-type-whos-value-can-be-changed-without-reassigning-an-example-of-a-mutable-data-type-is-the-builtin-list"></span>mutable<br>Mutability describes a data type whos value can be changed without reassigning.  An example of a mutable data type is the builtin list.</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numbers</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
</dd>
<dt id="term-as-you-can-see-we-have-changed-the-value-of-numbers-without-reassigning-a-new-value-numbers-in-plain-english-we-didn-t-use-an-equal-sign"><span id="term-you-might-have-noticed-when-working-with-strings-in-python-that-they-cannot-be-changed-in-place-all-string-operations-that-modify-the-string-return-a-brand-new-string-as-a-result-leaving-the-original-intact-this-is-is-known-as-immutability"></span>As you can see we have changed the value of <tt class="docutils literal"><span class="pre">numbers</span></tt> without reassigning a new value <tt class="docutils literal"><span class="pre">numbers</span></tt> (in plain english, we didn&#8217;t use an equal sign).<br>You might have noticed when working with strings in python that they cannot be changed &#8220;in place&#8221;. All string operations that modify the string, return a brand new string as a result, leaving the original intact. This is is known as immutability::</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="s1">&#39;hampster dance&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;hampster&#39;</span><span class="p">,</span> <span class="s1">&#39;chicken&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span>
<span class="go">&#39;hampster dance&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span>
<span class="go">&#39;chicken dance&#39;</span>
</pre></div>
</div>
</dd>
<dt id="term-the-value-of-s1-remained-the-same-but-the-result-of-the-replace-operation-was-stored-into-s2-because-strings-are-immutable-and-the-value-of-s1-cannot-change-without-assigning-a-brand-new-value-to-s1">The value of <tt class="docutils literal"><span class="pre">s1</span></tt> remained the same, but the result of the <tt class="docutils literal"><span class="pre">replace</span></tt> operation was stored into <tt class="docutils literal"><span class="pre">s2</span></tt>. Because strings are immutable and the value of <tt class="docutils literal"><span class="pre">s1</span></tt> cannot change without assigning a brand new value to <tt class="docutils literal"><span class="pre">s1</span></tt>::</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="s1">&#39;brand new dance!&#39;</span>
</pre></div>
</div>
</dd>
</dl>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="attributes.html" class="btn btn-neutral float-right" title="Attributes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tutorial.html" class="btn btn-neutral" title="Getting Started" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2009, Chad Dombrova.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>