
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>QAbstractSocket &#8212; Qt for Python</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <link rel="search" title="Search" href="../../search.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'https://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head><body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="https://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="https://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        
                        <li><a href="../../index.html">Qt for Python 5.13.0</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QAbstractSocket</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#virtual-functions">Virtual functions</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-PySide2.QtNetwork"></span><div class="section" id="qabstractsocket">
<span id="id1"></span><h1>QAbstractSocket<a class="headerlink" href="#qabstractsocket" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> class provides the base functionality common to all socket types. <a class="reference internal" href="#more">More</a>…</p>
</div></blockquote>
<div class="graphviz"><img src="../../_images/inheritance-78cbdf58f87383a14a21ed047d58e5d176527503.png" alt="Inheritance diagram of PySide2.QtNetwork.QAbstractSocket" usemap="#inheritance25bcf17f5d" class="inheritance graphviz" /></div>
<map id="inheritance25bcf17f5d" name="inheritance25bcf17f5d">
<area shape="rect" id="node1" href="#PySide2.QtNetwork.QAbstractSocket" title="QtNetwork.QAbstractSocket" alt="" coords="361,5,563,31"/>
<area shape="rect" id="node2" href="../QtCore/QIODevice.html#PySide2.QtCore.QIODevice" title="QtCore.QIODevice" alt="" coords="176,5,313,31"/>
<area shape="rect" id="node3" href="../QtCore/QObject.html#PySide2.QtCore.QObject" title="QtCore.QObject" alt="" coords="5,5,128,31"/>
</map><p><strong>Inherited by:</strong> <a class="reference internal" href="QSslSocket.html#qsslsocket"><span class="std std-ref">QSslSocket</span></a>, <a class="reference internal" href="QTcpSocket.html#qtcpsocket"><span class="std std-ref">QTcpSocket</span></a>, <a class="reference internal" href="QUdpSocket.html#qudpsocket"><span class="std std-ref">QUdpSocket</span></a></p>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.abort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.abort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abort</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind</span></code></a> ([port=0[, mode=QAbstractSocket.DefaultForPlatform]])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind</span></code></a> (address[, port=0[, mode=QAbstractSocket.DefaultForPlatform]])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.flush" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.flush"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flush</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.isValid" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.isValid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isValid</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localAddress</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localPort</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.pauseMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.pauseMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pauseMode</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerAddress</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerName</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerPort</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.protocolTag" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.protocolTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocolTag</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxy" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">proxy</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.readBufferSize" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.readBufferSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readBufferSize</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLocalAddress</span></code></a> (address)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLocalPort</span></code></a> (port)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPauseMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPauseMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPauseMode</span></code></a> (pauseMode)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerAddress</span></code></a> (address)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerName</span></code></a> (name)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerPort</span></code></a> (port)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProtocolTag" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProtocolTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setProtocolTag</span></code></a> (tag)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProxy" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProxy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setProxy</span></code></a> (networkProxy)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketError" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketError"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setSocketError</span></code></a> (socketError)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketState" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketState"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setSocketState</span></code></a> (state)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketType" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketType"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socketType</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state</span></code></a> ()</p></li>
</ul>
</div>
</div>
<div class="section" id="virtual-functions">
<h3>Virtual functions<a class="headerlink" href="#virtual-functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost</span></code></a> (address, port[, mode=QIODevice.ReadWrite])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost</span></code></a> (hostName, port[, mode=QIODevice.ReadWrite[, protocol=AnyIPProtocol]])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnectFromHost</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setReadBufferSize</span></code></a> (size)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketDescriptor" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketDescriptor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setSocketDescriptor</span></code></a> (socketDescriptor[, state=ConnectedState[, openMode=QIODevice.ReadWrite]])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketOption" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketOption"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setSocketOption</span></code></a> (option, value)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketDescriptor" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketDescriptor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socketDescriptor</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketOption" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketOption"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socketOption</span></code></a> (option)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForConnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForConnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForConnected</span></code></a> ([msecs=30000])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForDisconnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForDisconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForDisconnected</span></code></a> ([msecs=30000])</p></li>
</ul>
</div>
</div>
<div class="section" id="signals">
<h3>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnected</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error</span></code></a> (arg__1)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.hostFound" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.hostFound"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hostFound</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxyAuthenticationRequired" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxyAuthenticationRequired"><code class="xref py py-meth docutils literal notranslate"><span class="pre">proxyAuthenticationRequired</span></code></a> (proxy, authenticator)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.stateChanged" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.stateChanged"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stateChanged</span></code></a> (arg__1)</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote id="more">
<div><p><a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> is the base class for <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> and <a class="reference internal" href="QUdpSocket.html#PySide2.QtNetwork.QUdpSocket" title="PySide2.QtNetwork.QUdpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUdpSocket</span></code></a> and contains all common functionality of these two classes. If you need a socket, you have two options:</p>
<ul class="simple">
<li><p>Instantiate <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> or <a class="reference internal" href="QUdpSocket.html#PySide2.QtNetwork.QUdpSocket" title="PySide2.QtNetwork.QUdpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUdpSocket</span></code></a> .</p></li>
<li><p>Create a native socket descriptor, instantiate <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> , and call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketDescriptor" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketDescriptor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setSocketDescriptor()</span></code></a> to wrap the native socket.</p></li>
</ul>
<p>TCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. UDP (User Datagram Protocol) is an unreliable, datagram-oriented, connectionless protocol. In practice, this means that TCP is better suited for continuous transmission of data, whereas the more lightweight UDP can be used when reliability isn’t important.</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> ‘s API unifies most of the differences between the two protocols. For example, although UDP is connectionless, <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost()</span></code></a> establishes a virtual connection for UDP sockets, enabling you to use <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> in more or less the same way regardless of the underlying protocol. Internally, <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> remembers the address and port passed to <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost()</span></code></a> , and functions like <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> use these values.</p>
<p>At any time, <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> has a state (returned by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state()</span></code></a> ). The initial state is <code class="xref py py-attr docutils literal notranslate"><span class="pre">UnconnectedState</span></code> . After calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost()</span></code></a> , the socket first enters <code class="xref py py-attr docutils literal notranslate"><span class="pre">HostLookupState</span></code> . If the host is found, <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> enters <code class="xref py py-attr docutils literal notranslate"><span class="pre">ConnectingState</span></code> and emits the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.hostFound" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.hostFound"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hostFound()</span></code></a> signal. When the connection has been established, it enters <code class="xref py py-attr docutils literal notranslate"><span class="pre">ConnectedState</span></code> and emits <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected()</span></code></a> . If an error occurs at any stage, <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a> is emitted. Whenever the state changes, <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.stateChanged" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.stateChanged"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stateChanged()</span></code></a> is emitted. For convenience, <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.isValid" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.isValid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isValid()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the socket is ready for reading and writing, but note that the socket’s state must be <code class="xref py py-attr docutils literal notranslate"><span class="pre">ConnectedState</span></code> before reading and writing can occur.</p>
<p>Read or write data by calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> , or use the convenience functions <code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">readAll()</span></code> . <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> also inherits <code class="xref py py-meth docutils literal notranslate"><span class="pre">getChar()</span></code> , <code class="xref py py-meth docutils literal notranslate"><span class="pre">putChar()</span></code> , and <code class="xref py py-meth docutils literal notranslate"><span class="pre">ungetChar()</span></code> from <a class="reference internal" href="../QtCore/QIODevice.html#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> , which work on single bytes. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesWritten()</span></code> signal is emitted when data has been written to the socket. Note that Qt does not limit the write buffer size. You can monitor its size by listening to this signal.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code> signal is emitted every time a new chunk of data has arrived. <code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesAvailable()</span></code> then returns the number of bytes that are available for reading. Typically, you would connect the <code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code> signal to a slot and read all available data there. If you don’t read all the data at once, the remaining data will still be available later, and any new incoming data will be appended to <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> ‘s internal read buffer. To limit the size of the read buffer, call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setReadBufferSize()</span></code></a> .</p>
<p>To close the socket, call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnectFromHost()</span></code></a> . <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> enters <code class="xref py py-attr docutils literal notranslate"><span class="pre">ClosingState</span></code> . After all pending data has been written to the socket, <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> actually closes the socket, enters <code class="xref py py-attr docutils literal notranslate"><span class="pre">UnconnectedState</span></code> , and emits <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnected()</span></code></a> . If you want to abort a connection immediately, discarding all pending data, call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.abort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.abort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abort()</span></code></a> instead. If the remote host closes the connection, <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> will emit error( <code class="xref py py-attr docutils literal notranslate"><span class="pre">RemoteHostClosedError</span></code> ), during which the socket state will still be <code class="xref py py-attr docutils literal notranslate"><span class="pre">ConnectedState</span></code> , and then the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnected()</span></code></a> signal will be emitted.</p>
<p>The port and address of the connected peer is fetched by calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerPort()</span></code></a> and <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerAddress()</span></code></a> . <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerName()</span></code></a> returns the host name of the peer, as passed to <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost()</span></code></a> . <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localPort()</span></code></a> and <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localAddress()</span></code></a> return the port and address of the local socket.</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> provides a set of functions that suspend the calling thread until certain signals are emitted. These functions can be used to implement blocking sockets:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForConnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForConnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForConnected()</span></code></a> blocks until a connection has been established.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForReadyRead()</span></code> blocks until new data is available for reading.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForBytesWritten()</span></code> blocks until one payload of data has been written to the socket.</p></li>
<li><p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForDisconnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForDisconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForDisconnected()</span></code></a> blocks until the connection has closed.</p></li>
</ul>
<p>We show an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>numRead = 0
numReadTotal = 0

while(True):
    buffer  = socket.read(50)
    # do whatever with array
    numReadTotal += buffer.size()
    if (buffer.size() == 0 &amp;&amp; !socket.waitForReadyRead()):
        break
</pre></div>
</div>
<p>If <code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForReadyRead()</span></code> returns <code class="docutils literal notranslate"><span class="pre">false</span></code> , the connection has been closed or an error has occurred.</p>
<p>Programming with a blocking socket is radically different from programming with a non-blocking socket. A blocking socket doesn’t require an event loop and typically leads to simpler code. However, in a GUI application, blocking sockets should only be used in non-GUI threads, to avoid freezing the user interface. See the <span class="xref std std-ref">fortuneclient</span> and <span class="xref std std-ref">blockingfortuneclient</span> examples for an overview of both approaches.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We discourage the use of the blocking functions together with signals. One of the two possibilities should be used.</p>
</div>
<p><a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> can be used with <a class="reference internal" href="../QtCore/QTextStream.html#PySide2.QtCore.QTextStream" title="PySide2.QtCore.QTextStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTextStream</span></code></a> and <a class="reference internal" href="../QtCore/QDataStream.html#PySide2.QtCore.QDataStream" title="PySide2.QtCore.QDataStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">QDataStream</span></code></a> ‘s stream operators (operator&lt;&lt;() and operator&gt;&gt;()). There is one issue to be aware of, though: You must make sure that enough data is available before attempting to read it using operator&gt;&gt;().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="QNetworkAccessManager.html#PySide2.QtNetwork.QNetworkAccessManager" title="PySide2.QtNetwork.QNetworkAccessManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkAccessManager</span></code></a>  <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.QTcpServer" title="PySide2.QtNetwork.QTcpServer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpServer</span></code></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide2.QtNetwork.QAbstractSocket">
<em class="property">class </em><code class="sig-name descname">QAbstractSocket</code><span class="sig-paren">(</span><em class="sig-param">socketType</em>, <em class="sig-param">parent</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.QAbstractSocket" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param parent</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QObject</span></code></p>
</dd>
<dt class="field-even">param socketType</dt>
<dd class="field-even"><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketType</span></code></p>
</dd>
</dl>
</div></blockquote>
<p>Creates a new abstract socket of type <code class="docutils literal notranslate"><span class="pre">socketType</span></code> . The <code class="docutils literal notranslate"><span class="pre">parent</span></code> argument is passed to <a class="reference internal" href="../QtCore/QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">QObject</span></code></a> ‘s constructor.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketType" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketType"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socketType()</span></code></a>  <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a>  <a class="reference internal" href="QUdpSocket.html#PySide2.QtNetwork.QUdpSocket" title="PySide2.QtNetwork.QUdpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUdpSocket</span></code></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketType">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">SocketType</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketType" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the transport layer protocol.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 54%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QAbstractSocket.TcpSocket</p></td>
<td><p>TCP</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.UdpSocket</p></td>
<td><p>UDP</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.SctpSocket</p></td>
<td><p>SCTP</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.UnknownSocketType</p></td>
<td><p>Other than TCP, UDP and SCTP</p></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketType" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketType"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socketType()</span></code></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">NetworkLayerProtocol</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the network layer protocol values used in Qt.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 64%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QAbstractSocket.IPv4Protocol</p></td>
<td><p>IPv4</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.IPv6Protocol</p></td>
<td><p>IPv6</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.AnyIPProtocol</p></td>
<td><p>Either IPv4 or IPv6</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.UnknownNetworkLayerProtocol</p></td>
<td><p>Other than IPv4 and IPv6</p></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="QHostAddress.html#PySide2.QtNetwork.PySide2.QtNetwork.QHostAddress.protocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QHostAddress.protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocol()</span></code></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">SocketError</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the socket errors that can occur.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QAbstractSocket.ConnectionRefusedError</p></td>
<td><p>The connection was refused by the peer (or timed out).</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.RemoteHostClosedError</p></td>
<td><p>The remote host closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.HostNotFoundError</p></td>
<td><p>The host address was not found.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.SocketAccessError</p></td>
<td><p>The socket operation failed because the application lacked the required privileges.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.SocketResourceError</p></td>
<td><p>The local system ran out of resources (e.g., too many sockets).</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.SocketTimeoutError</p></td>
<td><p>The socket operation timed out.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.DatagramTooLargeError</p></td>
<td><p>The datagram was larger than the operating system’s limit (which can be as low as 8192 bytes).</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.NetworkError</p></td>
<td><p>An error occurred with the network (e.g., the network cable was accidentally plugged out).</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.AddressInUseError</p></td>
<td><p>The address specified to <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a> is already in use and was set to be exclusive.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.SocketAddressNotAvailableError</p></td>
<td><p>The address specified to <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a> does not belong to the host.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.UnsupportedSocketOperationError</p></td>
<td><p>The requested socket operation is not supported by the local operating system (e.g., lack of IPv6 support).</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.ProxyAuthenticationRequiredError</p></td>
<td><p>The socket is using a proxy, and the proxy requires authentication.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.SslHandshakeFailedError</p></td>
<td><p>The SSL/TLS handshake failed, so the connection was closed (only used in <a class="reference internal" href="QSslSocket.html#PySide2.QtNetwork.QSslSocket" title="PySide2.QtNetwork.QSslSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QSslSocket</span></code></a> )</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.UnfinishedSocketOperationError</p></td>
<td><p>Used by QAbstractSocketEngine only, The last operation attempted has not finished yet (still in progress in the background).</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.ProxyConnectionRefusedError</p></td>
<td><p>Could not contact the proxy server because the connection to that server was denied</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.ProxyConnectionClosedError</p></td>
<td><p>The connection to the proxy server was closed unexpectedly (before the connection to the final peer was established)</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.ProxyConnectionTimeoutError</p></td>
<td><p>The connection to the proxy server timed out or the proxy server stopped responding in the authentication phase.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.ProxyNotFoundError</p></td>
<td><p>The proxy address set with <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProxy" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProxy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setProxy()</span></code></a> (or the application proxy) was not found.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.ProxyProtocolError</p></td>
<td><p>The connection negotiation with the proxy server failed, because the response from the proxy server could not be understood.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.OperationError</p></td>
<td><p>An operation was attempted while the socket was in a state that did not permit it.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.SslInternalError</p></td>
<td><p>The SSL library being used reported an internal error. This is probably the result of a bad installation or misconfiguration of the library.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.SslInvalidUserDataError</p></td>
<td><p>Invalid data (certificate, key, cypher, etc.) was provided and its use resulted in an error in the SSL library.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.TemporaryError</p></td>
<td><p>A temporary error occurred (e.g., operation would block and socket is non-blocking).</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.UnknownSocketError</p></td>
<td><p>An unidentified error occurred.</p></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">SocketState</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the different states in which a socket can be.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QAbstractSocket.UnconnectedState</p></td>
<td><p>The socket is not connected.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.HostLookupState</p></td>
<td><p>The socket is performing a host name lookup.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.ConnectingState</p></td>
<td><p>The socket has started establishing a connection.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.ConnectedState</p></td>
<td><p>A connection is established.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.BoundState</p></td>
<td><p>The socket is bound to an address and port.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.ClosingState</p></td>
<td><p>The socket is about to close (data may still be waiting to be written).</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.ListeningState</p></td>
<td><p>For internal use only.</p></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state()</span></code></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketOption">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">SocketOption</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketOption" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum represents the options that can be set on a socket. If desired, they can be set after having received the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected()</span></code></a> signal from the socket or after having received a new socket from a <a class="reference internal" href="QTcpServer.html#PySide2.QtNetwork.QTcpServer" title="PySide2.QtNetwork.QTcpServer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpServer</span></code></a> .</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QAbstractSocket.LowDelayOption</p></td>
<td><p>Try to optimize the socket for low latency. For a <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> this would set the TCP_NODELAY option and disable Nagle’s algorithm. Set this to 1 to enable.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.KeepAliveOption</p></td>
<td><p>Set this to 1 to enable the SO_KEEPALIVE socket option</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.MulticastTtlOption</p></td>
<td><p>Set this to an integer value to set IP_MULTICAST_TTL (TTL for multicast datagrams) socket option.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.MulticastLoopbackOption</p></td>
<td><p>Set this to 1 to enable the IP_MULTICAST_LOOP (multicast loopback) socket option.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.TypeOfServiceOption</p></td>
<td><p>This option is not supported on Windows. This maps to the IP_TOS socket option. For possible values, see table below.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.SendBufferSizeSocketOption</p></td>
<td><p>Sets the socket send buffer size in bytes at the OS level. This maps to the SO_SNDBUF socket option. This option does not affect the <a class="reference internal" href="../QtCore/QIODevice.html#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> or <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> buffers. This enum value has been introduced in Qt 5.3.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.ReceiveBufferSizeSocketOption</p></td>
<td><p>Sets the socket receive buffer size in bytes at the OS level. This maps to the SO_RCVBUF socket option. This option does not affect the <a class="reference internal" href="../QtCore/QIODevice.html#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> or <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> buffers (see <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setReadBufferSize()</span></code></a> ). This enum value has been introduced in Qt 5.3.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.PathMtuSocketOption</p></td>
<td><p>Retrieves the Path Maximum Transmission Unit (PMTU) value currently known by the IP stack, if any. Some IP stacks also allow setting the MTU for transmission. This enum value was introduced in Qt 5.11.</p></td>
</tr>
</tbody>
</table>
<p>Possible values for ** are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Value</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p>224</p></td>
<td><p>Network control</p></td>
</tr>
<tr class="row-odd"><td><p>192</p></td>
<td><p>Internetwork control</p></td>
</tr>
<tr class="row-even"><td><p>160</p></td>
<td><p>CRITIC/ECP</p></td>
</tr>
<tr class="row-odd"><td><p>128</p></td>
<td><p>Flash override</p></td>
</tr>
<tr class="row-even"><td><p>96</p></td>
<td><p>Flash</p></td>
</tr>
<tr class="row-odd"><td><p>64</p></td>
<td><p>Immediate</p></td>
</tr>
<tr class="row-even"><td><p>32</p></td>
<td><p>Priority</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>Routine</p></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketOption" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketOption"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setSocketOption()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketOption" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketOption"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socketOption()</span></code></a></p>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">New in version 4.6.</span></p>
</div>
<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.BindFlag">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">BindFlag</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.BindFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the different flags you can pass to modify the behavior of <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a> .</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 5%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QAbstractSocket.ShareAddress</p></td>
<td><p>Allow other services to bind to the same address and port. This is useful when multiple processes share the load of a single service by listening to the same address and port (e.g., a web server with several pre-forked listeners can greatly improve response time). However, because any service is allowed to rebind, this option is subject to certain security considerations. Note that by combining this option with , you will also allow your service to rebind an existing shared address. On Unix, this is equivalent to the SO_REUSEADDR socket option. On Windows, this is the default behavior, so this option is ignored.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.DontShareAddress</p></td>
<td><p>Bind the address and port exclusively, so that no other services are allowed to rebind. By passing this option to <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a> , you are guaranteed that on successs, your service is the only one that listens to the address and port. No services are allowed to rebind, even if they pass . This option provides more security than , but on certain operating systems, it requires you to run the server with administrator privileges. On Unix and <span class="xref std std-ref">macOS</span> , not sharing is the default behavior for binding an address and port, so this option is ignored. On Windows, this option uses the SO_EXCLUSIVEADDRUSE socket option.</p></td>
</tr>
<tr class="row-even"><td><p>QAbstractSocket.ReuseAddressHint</p></td>
<td><p>Provides a hint to <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> that it should try to rebind the service even if the address and port are already bound by another socket. On Windows and Unix, this is equivalent to the SO_REUSEADDR socket option.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.DefaultForPlatform</p></td>
<td><p>The default option for the current platform. On Unix and <span class="xref std std-ref">macOS</span> , this is equivalent to ( + ), and on Windows, it is equivalent to .</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.PauseMode">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">PauseMode</code><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.PauseMode" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the behavior of when the socket should hold back with continuing data transfer. The only notification currently supported is <a class="reference internal" href="QSslSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sslErrors()</span></code></a> .</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QAbstractSocket.PauseNever</p></td>
<td><p>Do not pause data transfer on the socket. This is the default and matches the behavior of Qt 4.</p></td>
</tr>
<tr class="row-odd"><td><p>QAbstractSocket.PauseOnSslErrors</p></td>
<td><p>Pause data transfer on the socket upon receiving an SSL error notification. I.E. <a class="reference internal" href="QSslSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sslErrors()</span></code></a> .</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.abort">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Aborts the current connection and resets the socket. Unlike <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnectFromHost()</span></code></a> , this function immediately closes the socket, discarding any pending data in the write buffer.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnectFromHost()</span></code></a>  <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">bind</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">port=0</em><span class="optional">[</span>, <em class="sig-param">mode=QAbstractSocket.DefaultForPlatform</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>port</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">quint16</span></code></p></li>
<li><p><strong>mode</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">BindMode</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>This is an overloaded function.</p>
<p>Binds to <a class="reference internal" href="QHostAddress.html#PySide2.QtNetwork.QHostAddress" title="PySide2.QtNetwork.QHostAddress"><code class="xref py py-class docutils literal notranslate"><span class="pre">QHostAddress</span></code></a> :Any on port <code class="docutils literal notranslate"><span class="pre">port</span></code> , using the <code class="xref py py-class docutils literal notranslate"><span class="pre">BindMode</span></code> <code class="docutils literal notranslate"><span class="pre">mode</span></code> .</p>
<p>By default, the socket is bound using the <code class="xref py py-attr docutils literal notranslate"><span class="pre">DefaultForPlatform</span></code> <code class="xref py py-class docutils literal notranslate"><span class="pre">BindMode</span></code> . If a port is not specified, a random port is chosen.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">bind</code><span class="sig-paren">(</span><em class="sig-param">address</em><span class="optional">[</span>, <em class="sig-param">port=0</em><span class="optional">[</span>, <em class="sig-param">mode=QAbstractSocket.DefaultForPlatform</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> – <a class="reference internal" href="QHostAddress.html#PySide2.QtNetwork.QHostAddress" title="PySide2.QtNetwork.QHostAddress"><code class="xref py py-class docutils literal notranslate"><span class="pre">QHostAddress</span></code></a></p></li>
<li><p><strong>port</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">quint16</span></code></p></li>
<li><p><strong>mode</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">BindMode</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Binds to <code class="docutils literal notranslate"><span class="pre">address</span></code> on port <code class="docutils literal notranslate"><span class="pre">port</span></code> , using the <code class="xref py py-class docutils literal notranslate"><span class="pre">BindMode</span></code> <code class="docutils literal notranslate"><span class="pre">mode</span></code> .</p>
<p>For UDP sockets, after binding, the signal <code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code> is emitted whenever a UDP datagram arrives on the specified address and port. Thus, this function is useful to write UDP servers.</p>
<p>For TCP sockets, this function may be used to specify which interface to use for an outgoing connection, which is useful in case of multiple network interfaces.</p>
<p>By default, the socket is bound using the <code class="xref py py-attr docutils literal notranslate"><span class="pre">DefaultForPlatform</span></code> <code class="xref py py-class docutils literal notranslate"><span class="pre">BindMode</span></code> . If a port is not specified, a random port is chosen.</p>
<p>On success, the function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> and the socket enters <code class="xref py py-attr docutils literal notranslate"><span class="pre">BoundState</span></code> ; otherwise it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">connectToHost</code><span class="sig-paren">(</span><em class="sig-param">address</em>, <em class="sig-param">port</em><span class="optional">[</span>, <em class="sig-param">mode=QIODevice.ReadWrite</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>address</strong> – <a class="reference internal" href="QHostAddress.html#PySide2.QtNetwork.QHostAddress" title="PySide2.QtNetwork.QHostAddress"><code class="xref py py-class docutils literal notranslate"><span class="pre">QHostAddress</span></code></a></p></li>
<li><p><strong>port</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">quint16</span></code></p></li>
<li><p><strong>mode</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p></li>
</ul>
</dd>
</dl>
<p>This is an overloaded function.</p>
<p>Attempts to make a connection to <code class="docutils literal notranslate"><span class="pre">address</span></code> on port <code class="docutils literal notranslate"><span class="pre">port</span></code> .</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">connectToHost</code><span class="sig-paren">(</span><em class="sig-param">hostName</em>, <em class="sig-param">port</em><span class="optional">[</span>, <em class="sig-param">mode=QIODevice.ReadWrite</em><span class="optional">[</span>, <em class="sig-param">protocol=AnyIPProtocol</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hostName</strong> – unicode</p></li>
<li><p><strong>port</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">quint16</span></code></p></li>
<li><p><strong>mode</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p></li>
<li><p><strong>protocol</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.NetworkLayerProtocol"><code class="xref py py-attr docutils literal notranslate"><span class="pre">NetworkLayerProtocol</span></code></a></p></li>
</ul>
</dd>
</dl>
<p>Attempts to make a connection to <code class="docutils literal notranslate"><span class="pre">hostName</span></code> on the given <code class="docutils literal notranslate"><span class="pre">port</span></code> . The <code class="docutils literal notranslate"><span class="pre">protocol</span></code> parameter can be used to specify which network protocol to use (eg. IPv4 or IPv6).</p>
<p>The socket is opened in the given <code class="docutils literal notranslate"><span class="pre">openMode</span></code> and first enters <code class="xref py py-attr docutils literal notranslate"><span class="pre">HostLookupState</span></code> , then performs a host name lookup of <code class="docutils literal notranslate"><span class="pre">hostName</span></code> . If the lookup succeeds, <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.hostFound" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.hostFound"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hostFound()</span></code></a> is emitted and <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> enters <code class="xref py py-attr docutils literal notranslate"><span class="pre">ConnectingState</span></code> . It then attempts to connect to the address or addresses returned by the lookup. Finally, if a connection is established, <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> enters <code class="xref py py-attr docutils literal notranslate"><span class="pre">ConnectedState</span></code> and emits <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected()</span></code></a> .</p>
<p>At any point, the socket can emit <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a> to signal that an error occurred.</p>
<p><code class="docutils literal notranslate"><span class="pre">hostName</span></code> may be an IP address in string form (e.g., “43.195.83.32”), or it may be a host name (e.g., “example.com”). <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> will do a lookup only if required. <code class="docutils literal notranslate"><span class="pre">port</span></code> is in native byte order.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerName()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForConnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForConnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForConnected()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">disconnectFromHost</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to close the socket. If there is pending data waiting to be written, <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> will enter <code class="xref py py-attr docutils literal notranslate"><span class="pre">ClosingState</span></code> and wait until all data has been written. Eventually, it will enter <code class="xref py py-attr docutils literal notranslate"><span class="pre">UnconnectedState</span></code> and emit the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnected()</span></code></a> signal.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">disconnected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketError</span></code></a></p>
</dd>
</dl>
<p>Returns the type of error that last occurred.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state()</span></code></a>  <code class="xref py py-meth docutils literal notranslate"><span class="pre">errorString()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">error</code><span class="sig-paren">(</span><em class="sig-param">arg__1</em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg__1</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketError</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.flush">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.flush" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> ; otherwise false is returned.</p>
<p>Call this function if you need <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call <code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForBytesWritten()</span></code> instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>  <code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForBytesWritten()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.hostFound">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">hostFound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.hostFound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.isValid">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">isValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.isValid" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the socket is valid and ready for use; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The socket’s state must be <code class="xref py py-attr docutils literal notranslate"><span class="pre">ConnectedState</span></code> before reading and writing can occur.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">localAddress</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="QHostAddress.html#PySide2.QtNetwork.QHostAddress" title="PySide2.QtNetwork.QHostAddress"><code class="xref py py-class docutils literal notranslate"><span class="pre">QHostAddress</span></code></a></p>
</dd>
</dl>
<p>Returns the host address of the local socket if available; otherwise returns <code class="xref py py-attr docutils literal notranslate"><span class="pre">Null</span></code> .</p>
<p>This is normally the main IP address of the host, but can be <code class="xref py py-attr docutils literal notranslate"><span class="pre">LocalHost</span></code> (127.0.0.1) for connections to the local host.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLocalAddress()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">localPort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">quint16</span></code></p>
</dd>
</dl>
<p>Returns the host port number (in native byte order) of the local socket if available; otherwise returns 0.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLocalPort()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.pauseMode">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">pauseMode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.pauseMode" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">PauseModes</span></code></p>
</dd>
</dl>
<p>Returns the pause mode of this socket.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPauseMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPauseMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPauseMode()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">peerAddress</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="QHostAddress.html#PySide2.QtNetwork.QHostAddress" title="PySide2.QtNetwork.QHostAddress"><code class="xref py py-class docutils literal notranslate"><span class="pre">QHostAddress</span></code></a></p>
</dd>
</dl>
<p>Returns the address of the connected peer if the socket is in <code class="xref py py-attr docutils literal notranslate"><span class="pre">ConnectedState</span></code> ; otherwise returns <code class="xref py py-attr docutils literal notranslate"><span class="pre">Null</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerName()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerAddress()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">peerName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>unicode</p>
</dd>
</dl>
<p>Returns the name of the peer as specified by <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost()</span></code></a> , or an empty <code class="xref py py-class docutils literal notranslate"><span class="pre">QString</span></code> if <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost()</span></code></a> has not been called.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerName()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">peerPort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">quint16</span></code></p>
</dd>
</dl>
<p>Returns the port of the connected peer if the socket is in <code class="xref py py-attr docutils literal notranslate"><span class="pre">ConnectedState</span></code> ; otherwise returns 0.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerPort()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.protocolTag">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">protocolTag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.protocolTag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>unicode</p>
</dd>
</dl>
<p>Returns the protocol tag for this socket. If the protocol tag is set then this is passed to <a class="reference internal" href="QNetworkProxyQuery.html#PySide2.QtNetwork.QNetworkProxyQuery" title="PySide2.QtNetwork.QNetworkProxyQuery"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkProxyQuery</span></code></a> when this is created internally to indicate the protocol tag to be used.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProtocolTag" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProtocolTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setProtocolTag()</span></code></a>  <a class="reference internal" href="QNetworkProxyQuery.html#PySide2.QtNetwork.QNetworkProxyQuery" title="PySide2.QtNetwork.QNetworkProxyQuery"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkProxyQuery</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxy">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">proxy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxy" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="QNetworkProxy.html#PySide2.QtNetwork.QNetworkProxy" title="PySide2.QtNetwork.QNetworkProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkProxy</span></code></a></p>
</dd>
</dl>
<p>Returns the network proxy for this socket. By default <code class="xref py py-attr docutils literal notranslate"><span class="pre">DefaultProxy</span></code> is used, which means this socket will query the default proxy settings for the application.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProxy" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProxy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setProxy()</span></code></a>  <a class="reference internal" href="QNetworkProxy.html#PySide2.QtNetwork.QNetworkProxy" title="PySide2.QtNetwork.QNetworkProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkProxy</span></code></a>  <a class="reference internal" href="QNetworkProxyFactory.html#PySide2.QtNetwork.QNetworkProxyFactory" title="PySide2.QtNetwork.QNetworkProxyFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkProxyFactory</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxyAuthenticationRequired">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">proxyAuthenticationRequired</code><span class="sig-paren">(</span><em class="sig-param">proxy</em>, <em class="sig-param">authenticator</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxyAuthenticationRequired" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>proxy</strong> – <a class="reference internal" href="QNetworkProxy.html#PySide2.QtNetwork.QNetworkProxy" title="PySide2.QtNetwork.QNetworkProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkProxy</span></code></a></p></li>
<li><p><strong>authenticator</strong> – <a class="reference internal" href="QAuthenticator.html#PySide2.QtNetwork.QAuthenticator" title="PySide2.QtNetwork.QAuthenticator"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAuthenticator</span></code></a></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.readBufferSize">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">readBufferSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.readBufferSize" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
<p>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">readAll()</span></code> .</p>
<p>A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setReadBufferSize()</span></code></a>  <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">resume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Continues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is <a class="reference internal" href="QSslSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sslErrors()</span></code></a> . Calling this method if the socket is not paused results in undefined behavior.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.pauseMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.pauseMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pauseMode()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPauseMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPauseMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPauseMode()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setLocalAddress</code><span class="sig-paren">(</span><em class="sig-param">address</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>address</strong> – <a class="reference internal" href="QHostAddress.html#PySide2.QtNetwork.QHostAddress" title="PySide2.QtNetwork.QHostAddress"><code class="xref py py-class docutils literal notranslate"><span class="pre">QHostAddress</span></code></a></p>
</dd>
</dl>
<p>Sets the address on the local side of a connection to <code class="docutils literal notranslate"><span class="pre">address</span></code> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> to change the return value of the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localAddress()</span></code></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<p>Note that this function does not bind the local address of the socket prior to a connection (e.g., <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a> ).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLocalPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerAddress()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setLocalPort</code><span class="sig-paren">(</span><em class="sig-param">port</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>port</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">quint16</span></code></p>
</dd>
</dl>
<p>Sets the port on the local side of a connection to <code class="docutils literal notranslate"><span class="pre">port</span></code> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> to change the return value of the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localPort()</span></code></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<p>Note that this function does not bind the local port of the socket prior to a connection (e.g., <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a> ).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.localAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLocalAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerPort()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPauseMode">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setPauseMode</code><span class="sig-paren">(</span><em class="sig-param">pauseMode</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPauseMode" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pauseMode</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">PauseModes</span></code></p>
</dd>
</dl>
<p>Controls whether to pause upon receiving a notification. The <code class="docutils literal notranslate"><span class="pre">pauseMode</span></code> parameter specifies the conditions in which the socket should be paused. The only notification currently supported is <a class="reference internal" href="QSslSocket.html#PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors" title="PySide2.QtNetwork.PySide2.QtNetwork.QSslSocket.sslErrors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sslErrors()</span></code></a> . If set to <code class="xref py py-attr docutils literal notranslate"><span class="pre">PauseOnSslErrors</span></code> , data transfer on the socket will be paused and needs to be enabled explicitly again by calling <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume()</span></code></a> . By default this option is set to <code class="xref py py-attr docutils literal notranslate"><span class="pre">PauseNever</span></code> . This option must be called before connecting to the server, otherwise it will result in undefined behavior.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.pauseMode" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.pauseMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pauseMode()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.resume"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resume()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setPeerAddress</code><span class="sig-paren">(</span><em class="sig-param">address</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>address</strong> – <a class="reference internal" href="QHostAddress.html#PySide2.QtNetwork.QHostAddress" title="PySide2.QtNetwork.QHostAddress"><code class="xref py py-class docutils literal notranslate"><span class="pre">QHostAddress</span></code></a></p>
</dd>
</dl>
<p>Sets the address of the remote side of the connection to <code class="docutils literal notranslate"><span class="pre">address</span></code> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> to change the return value of the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerAddress()</span></code></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLocalAddress()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerName">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setPeerName</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerName" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> – unicode</p>
</dd>
</dl>
<p>Sets the host name of the remote peer to <code class="docutils literal notranslate"><span class="pre">name</span></code> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> to change the return value of the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerName()</span></code></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerName()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setPeerPort</code><span class="sig-paren">(</span><em class="sig-param">port</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerPort" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>port</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">quint16</span></code></p>
</dd>
</dl>
<p>Sets the port of the remote side of the connection to <code class="docutils literal notranslate"><span class="pre">port</span></code> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> to change the return value of the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerPort()</span></code></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.peerPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peerPort()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setPeerAddress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPeerAddress()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setLocalPort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLocalPort()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProtocolTag">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setProtocolTag</code><span class="sig-paren">(</span><em class="sig-param">tag</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProtocolTag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tag</strong> – unicode</p>
</dd>
</dl>
<p>Sets the protocol tag for this socket to <code class="docutils literal notranslate"><span class="pre">tag</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.protocolTag" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.protocolTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">protocolTag()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProxy">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setProxy</code><span class="sig-paren">(</span><em class="sig-param">networkProxy</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setProxy" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>networkProxy</strong> – <a class="reference internal" href="QNetworkProxy.html#PySide2.QtNetwork.QNetworkProxy" title="PySide2.QtNetwork.QNetworkProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkProxy</span></code></a></p>
</dd>
</dl>
<p>Sets the explicit network proxy for this socket to <code class="docutils literal notranslate"><span class="pre">networkProxy</span></code> .</p>
<p>To disable the use of a proxy for this socket, use the <code class="xref py py-attr docutils literal notranslate"><span class="pre">NoProxy</span></code> proxy type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">socket</span><span class="o">.</span><span class="n">setProxy</span><span class="p">(</span><span class="n">QNetworkProxy</span><span class="o">.</span><span class="n">NoProxy</span><span class="p">)</span>
</pre></div>
</div>
<p>The default value for the proxy is <code class="xref py py-attr docutils literal notranslate"><span class="pre">DefaultProxy</span></code> , which means the socket will use the application settings: if a proxy is set with <a class="reference internal" href="QNetworkProxy.html#PySide2.QtNetwork.PySide2.QtNetwork.QNetworkProxy.setApplicationProxy" title="PySide2.QtNetwork.PySide2.QtNetwork.QNetworkProxy.setApplicationProxy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setApplicationProxy</span></code></a> , it will use that; otherwise, if a factory is set with <a class="reference internal" href="QNetworkProxyFactory.html#PySide2.QtNetwork.PySide2.QtNetwork.QNetworkProxyFactory.setApplicationProxyFactory" title="PySide2.QtNetwork.PySide2.QtNetwork.QNetworkProxyFactory.setApplicationProxyFactory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setApplicationProxyFactory</span></code></a> , it will query that factory with type <code class="xref py py-attr docutils literal notranslate"><span class="pre">TcpSocket</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxy" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.proxy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">proxy()</span></code></a>  <a class="reference internal" href="QNetworkProxy.html#PySide2.QtNetwork.QNetworkProxy" title="PySide2.QtNetwork.QNetworkProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkProxy</span></code></a>  <a class="reference internal" href="QNetworkProxyFactory.html#PySide2.QtNetwork.PySide2.QtNetwork.QNetworkProxyFactory.queryProxy" title="PySide2.QtNetwork.PySide2.QtNetwork.QNetworkProxyFactory.queryProxy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">queryProxy()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setReadBufferSize</code><span class="sig-paren">(</span><em class="sig-param">size</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setReadBufferSize" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
<p>Sets the size of <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> ‘s internal read buffer to be <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes.</p>
<p>If the buffer size is limited to a certain size, <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> won’t buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</p>
<p>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</p>
<p>Only <a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> uses <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> ‘s internal buffer; <a class="reference internal" href="QUdpSocket.html#PySide2.QtNetwork.QUdpSocket" title="PySide2.QtNetwork.QUdpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUdpSocket</span></code></a> does not use any buffering at all, but rather relies on the implicit buffering provided by the operating system. Because of this, calling this function on <a class="reference internal" href="QUdpSocket.html#PySide2.QtNetwork.QUdpSocket" title="PySide2.QtNetwork.QUdpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUdpSocket</span></code></a> has no effect.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.readBufferSize" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.readBufferSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readBufferSize()</span></code></a>  <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketDescriptor">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setSocketDescriptor</code><span class="sig-paren">(</span><em class="sig-param">socketDescriptor</em><span class="optional">[</span>, <em class="sig-param">state=ConnectedState</em><span class="optional">[</span>, <em class="sig-param">openMode=QIODevice.ReadWrite</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>socketDescriptor</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qintptr</span></code></p></li>
<li><p><strong>state</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketState</span></code></a></p></li>
<li><p><strong>openMode</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Initializes <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> with the native socket descriptor <code class="docutils literal notranslate"><span class="pre">socketDescriptor</span></code> . Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">socketDescriptor</span></code> is accepted as a valid socket descriptor; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> . The socket is opened in the mode specified by <code class="docutils literal notranslate"><span class="pre">openMode</span></code> , and enters the socket state specified by <code class="docutils literal notranslate"><span class="pre">socketState</span></code> . Read and write buffers are cleared, discarding any pending data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is not possible to initialize two abstract sockets with the same native socket descriptor.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketDescriptor" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketDescriptor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socketDescriptor()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketError">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setSocketError</code><span class="sig-paren">(</span><em class="sig-param">socketError</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketError" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>socketError</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketError"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketError</span></code></a></p>
</dd>
</dl>
<p>Sets the type of error that last occurred to <code class="docutils literal notranslate"><span class="pre">socketError</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketState" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketState"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setSocketState()</span></code></a>  <code class="xref py py-meth docutils literal notranslate"><span class="pre">setErrorString()</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketOption">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setSocketOption</code><span class="sig-paren">(</span><em class="sig-param">option</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketOption" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>option</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketOption" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketOption"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketOption</span></code></a></p></li>
<li><p><strong>value</strong> – object</p></li>
</ul>
</dd>
</dl>
<p>Sets the given <code class="docutils literal notranslate"><span class="pre">option</span></code> to the value described by <code class="docutils literal notranslate"><span class="pre">value</span></code> .</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On Windows Runtime, <code class="xref py py-attr docutils literal notranslate"><span class="pre">KeepAliveOption</span></code> must be set before the socket is connected.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketOption" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketOption"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socketOption()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketState">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">setSocketState</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketState" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>state</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketState</span></code></a></p>
</dd>
</dl>
<p>Sets the state of the socket to <code class="docutils literal notranslate"><span class="pre">state</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketDescriptor">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">socketDescriptor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">qintptr</span></code></p>
</dd>
</dl>
<p>Returns the native socket descriptor of the <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> object if this is available; otherwise returns -1.</p>
<p>If the socket is using <a class="reference internal" href="QNetworkProxy.html#PySide2.QtNetwork.QNetworkProxy" title="PySide2.QtNetwork.QNetworkProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNetworkProxy</span></code></a> , the returned descriptor may not be usable with native socket functions.</p>
<p>The socket descriptor is not available when <a class="reference internal" href="#PySide2.QtNetwork.QAbstractSocket" title="PySide2.QtNetwork.QAbstractSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractSocket</span></code></a> is in <code class="xref py py-attr docutils literal notranslate"><span class="pre">UnconnectedState</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketDescriptor" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketDescriptor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setSocketDescriptor()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketOption">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">socketOption</code><span class="sig-paren">(</span><em class="sig-param">option</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketOption" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>option</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketOption" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketOption"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketOption</span></code></a></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object</p>
</dd>
</dl>
<p>Returns the value of the <code class="docutils literal notranslate"><span class="pre">option</span></code> option.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketOption" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.setSocketOption"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setSocketOption()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketType">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">socketType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.socketType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketType" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketType"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketType</span></code></a></p>
</dd>
</dl>
<p>Returns the socket type (TCP, UDP, or other).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a>  <a class="reference internal" href="QUdpSocket.html#PySide2.QtNetwork.QUdpSocket" title="PySide2.QtNetwork.QUdpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QUdpSocket</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.state" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketState</span></code></a></p>
</dd>
</dl>
<p>Returns the state of the socket.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.stateChanged">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">stateChanged</code><span class="sig-paren">(</span><em class="sig-param">arg__1</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.stateChanged" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg__1</strong> – <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.SocketState"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SocketState</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForConnected">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">waitForConnected</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">msecs=30000</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForConnected" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msecs</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Waits until the socket is connected, up to <code class="docutils literal notranslate"><span class="pre">msecs</span></code> milliseconds. If the connection has been established, this function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> ; otherwise it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> . In the case where it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> , you can call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a> to determine the cause of the error.</p>
<p>The following example waits up to one second for a connection to be established:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">socket</span><span class="o">.</span><span class="n">connectToHost</span><span class="p">(</span><span class="s2">&quot;imap&quot;</span><span class="p">,</span> <span class="mi">143</span><span class="p">)</span>
<span class="k">if</span> <span class="n">socket</span><span class="o">.</span><span class="n">waitForConnected</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="nb">print</span> <span class="s2">&quot;Connected!&quot;</span>
</pre></div>
</div>
<p>If msecs is -1, this function will not time out.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function may wait slightly longer than <code class="docutils literal notranslate"><span class="pre">msecs</span></code> , depending on the time it takes to complete the host lookup.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Multiple calls to this functions do not accumulate the time. If the function times out, the connecting process will be aborted.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function may fail randomly on Windows. Consider using the event loop and the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected()</span></code></a> signal if your software will run on Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connectToHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connectToHost()</span></code></a>  <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.connected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connected()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForDisconnected">
<code class="sig-prename descclassname">PySide2.QtNetwork.QAbstractSocket.</code><code class="sig-name descname">waitForDisconnected</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">msecs=30000</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.waitForDisconnected" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msecs</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Waits until the socket has disconnected, up to <code class="docutils literal notranslate"><span class="pre">msecs</span></code> milliseconds. If the connection has been disconnected, this function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> ; otherwise it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> . In the case where it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> , you can call <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a> to determine the cause of the error.</p>
<p>The following example waits up to one second for a connection to be closed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">socket</span><span class="o">.</span><span class="n">disconnectFromHost</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">socket</span><span class="o">.</span><span class="n">state</span><span class="p">()</span> <span class="o">==</span> <span class="n">QAbstractSocket</span><span class="o">.</span><span class="n">UnconnectedState</span> <span class="ow">or</span> \
        <span class="n">socket</span><span class="o">.</span><span class="n">waitForDisconnected</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;Disconnected!&quot;</span>
</pre></div>
</div>
<p>If msecs is -1, this function will not time out.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function may fail randomly on Windows. Consider using the event loop and the <a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnected"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnected()</span></code></a> signal if your software will run on Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide2.QtNetwork.PySide2.QtNetwork.QAbstractSocket.disconnectFromHost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">disconnectFromHost()</span></code></a>  <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2019 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>