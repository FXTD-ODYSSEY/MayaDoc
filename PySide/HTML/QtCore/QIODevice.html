
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>QIODevice &#8212; Qt for Python</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <link rel="search" title="Search" href="../../search.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'https://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head><body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="https://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="https://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        
                        <li><a href="../../index.html">Qt for Python 5.13.0</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QIODevice</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#virtual-functions">Virtual functions</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-PySide2.QtCore"></span><div class="section" id="qiodevice">
<span id="id1"></span><h1>QIODevice<a class="headerlink" href="#qiodevice" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> class is the base interface class of all I/O devices in Qt. <a class="reference internal" href="#more">More</a>…</p>
</div></blockquote>
<div class="graphviz"><img src="../../_images/inheritance-11355e40e207075815925ccfbfcb3c9e672b7d73.png" alt="Inheritance diagram of PySide2.QtCore.QIODevice" usemap="#inheritancebe2ae3141c" class="inheritance graphviz" /></div>
<map id="inheritancebe2ae3141c" name="inheritancebe2ae3141c">
<area shape="rect" id="node1" href="#PySide2.QtCore.QIODevice" title="QtCore.QIODevice" alt="" coords="176,5,313,31"/>
<area shape="rect" id="node2" href="QObject.html#PySide2.QtCore.QObject" title="QtCore.QObject" alt="" coords="5,5,128,31"/>
</map><p><strong>Inherited by:</strong> <a class="reference internal" href="QBuffer.html#qbuffer"><span class="std std-ref">QBuffer</span></a>, <a class="reference internal" href="QFile.html#qfile"><span class="std std-ref">QFile</span></a>, <a class="reference internal" href="QFileDevice.html#qfiledevice"><span class="std std-ref">QFileDevice</span></a>, <a class="reference internal" href="QProcess.html#qprocess"><span class="std std-ref">QProcess</span></a>, <a class="reference internal" href="QSaveFile.html#qsavefile"><span class="std std-ref">QSaveFile</span></a>, <a class="reference internal" href="QTemporaryFile.html#qtemporaryfile"><span class="std std-ref">QTemporaryFile</span></a>, <a class="reference internal" href="../QtNetwork/QAbstractSocket.html#qabstractsocket"><span class="std std-ref">QAbstractSocket</span></a>, <a class="reference internal" href="../QtNetwork/QLocalSocket.html#qlocalsocket"><span class="std std-ref">QLocalSocket</span></a>, <a class="reference internal" href="../QtNetwork/QNetworkReply.html#qnetworkreply"><span class="std std-ref">QNetworkReply</span></a>, <a class="reference internal" href="../QtNetwork/QSslSocket.html#qsslsocket"><span class="std std-ref">QSslSocket</span></a>, <a class="reference internal" href="../QtNetwork/QTcpSocket.html#qtcpsocket"><span class="std std-ref">QTcpSocket</span></a>, <a class="reference internal" href="../QtNetwork/QUdpSocket.html#qudpsocket"><span class="std std-ref">QUdpSocket</span></a></p>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commitTransaction</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.currentReadChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.currentReadChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">currentReadChannel</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.currentWriteChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.currentWriteChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">currentWriteChannel</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.errorString" title="PySide2.QtCore.PySide2.QtCore.QIODevice.errorString"><code class="xref py py-meth docutils literal notranslate"><span class="pre">errorString</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.getChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.getChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getChar</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isOpen" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isOpen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isOpen</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isReadable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isReadable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isReadable</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isTextModeEnabled" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isTextModeEnabled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isTextModeEnabled</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isTransactionStarted" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isTransactionStarted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isTransactionStarted</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isWritable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isWritable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isWritable</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.openMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.openMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">openMode</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.peek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.peek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peek</span></code></a> (maxlen)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.putChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.putChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">putChar</span></code></a> (c)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read</span></code></a> (maxlen)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readAll" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readAll"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readAll</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readChannelCount</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine</span></code></a> ([maxlen=0])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rollbackTransaction</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentReadChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentReadChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setCurrentReadChannel</span></code></a> (channel)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentWriteChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentWriteChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setCurrentWriteChannel</span></code></a> (channel)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setErrorString" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setErrorString"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setErrorString</span></code></a> (errorString)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setOpenMode</span></code></a> (openMode)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setTextModeEnabled" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setTextModeEnabled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setTextModeEnabled</span></code></a> (enabled)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.skip" title="PySide2.QtCore.PySide2.QtCore.QIODevice.skip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">skip</span></code></a> (maxSize)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTransaction</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.ungetChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.ungetChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ungetChar</span></code></a> (c)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.write" title="PySide2.QtCore.PySide2.QtCore.QIODevice.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write</span></code></a> (data)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeChannelCount</span></code></a> ()</p></li>
</ul>
</div>
</div>
<div class="section" id="virtual-functions">
<h3>Virtual functions<a class="headerlink" href="#virtual-functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.atEnd" title="PySide2.QtCore.PySide2.QtCore.QIODevice.atEnd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">atEnd</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesAvailable</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesToWrite" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesToWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesToWrite</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.canReadLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.canReadLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canReadLine</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.close" title="PySide2.QtCore.PySide2.QtCore.QIODevice.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isSequential</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.open" title="PySide2.QtCore.PySide2.QtCore.QIODevice.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open</span></code></a> (mode)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.pos" title="PySide2.QtCore.PySide2.QtCore.QIODevice.pos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pos</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readData" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readData"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readData</span></code></a> (, maxlen)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLineData" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLineData"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLineData</span></code></a> (, maxlen)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.reset" title="PySide2.QtCore.PySide2.QtCore.QIODevice.reset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.seek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek</span></code></a> (pos)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.size" title="PySide2.QtCore.PySide2.QtCore.QIODevice.size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">size</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.waitForBytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.waitForBytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForBytesWritten</span></code></a> (msecs)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.waitForReadyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.waitForReadyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForReadyRead</span></code></a> (msecs)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeData" title="PySide2.QtCore.PySide2.QtCore.QIODevice.writeData"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeData</span></code></a> (data, len)</p></li>
</ul>
</div>
</div>
<div class="section" id="signals">
<h3>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.aboutToClose" title="PySide2.QtCore.PySide2.QtCore.QIODevice.aboutToClose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aboutToClose</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesWritten</span></code></a> (bytes)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.channelBytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.channelBytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">channelBytesWritten</span></code></a> (channel, bytes)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.channelReadyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.channelReadyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">channelReadyRead</span></code></a> (channel)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelFinished" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelFinished"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readChannelFinished</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead</span></code></a> ()</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote id="more">
<div><p><a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> provides both a common implementation and an abstract interface for devices that support reading and writing of blocks of data, such as <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> , <a class="reference internal" href="QBuffer.html#PySide2.QtCore.QBuffer" title="PySide2.QtCore.QBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBuffer</span></code></a> and <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> . <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> is abstract and cannot be instantiated, but it is common to use the interface it defines to provide device-independent I/O features. For example, Qt’s XML classes operate on a <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> pointer, allowing them to be used with various devices (such as files and buffers).</p>
<p>Before accessing the device, <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.open" title="PySide2.QtCore.PySide2.QtCore.QIODevice.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> must be called to set the correct <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code> (such as <code class="xref py py-attr docutils literal notranslate"><span class="pre">ReadOnly</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">ReadWrite</span></code> ). You can then write to the device with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.write" title="PySide2.QtCore.PySide2.QtCore.QIODevice.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> or <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.putChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.putChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">putChar()</span></code></a> , and read by calling either <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> , <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine()</span></code></a> , or <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readAll" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readAll"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readAll()</span></code></a> . Call <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.close" title="PySide2.QtCore.PySide2.QtCore.QIODevice.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> when you are done with the device.</p>
<p><a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> distinguishes between two types of devices: random-access devices and sequential devices.</p>
<ul class="simple">
<li><p>Random-access devices support seeking to arbitrary positions using <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.seek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a> . The current position in the file is available by calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.pos" title="PySide2.QtCore.PySide2.QtCore.QIODevice.pos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pos()</span></code></a> . <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> and <a class="reference internal" href="QBuffer.html#PySide2.QtCore.QBuffer" title="PySide2.QtCore.QBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBuffer</span></code></a> are examples of random-access devices.</p></li>
<li><p>Sequential devices don’t support seeking to arbitrary positions. The data must be read in one pass. The functions <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.pos" title="PySide2.QtCore.PySide2.QtCore.QIODevice.pos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pos()</span></code></a> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.size" title="PySide2.QtCore.PySide2.QtCore.QIODevice.size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">size()</span></code></a> don’t work for sequential devices. <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> and <a class="reference internal" href="QProcess.html#PySide2.QtCore.QProcess" title="PySide2.QtCore.QProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">QProcess</span></code></a> are examples of sequential devices.</p></li>
</ul>
<p>You can use <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isSequential()</span></code></a> to determine the type of device.</p>
<p><a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> emits <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code></a> when new data is available for reading; for example, if new data has arrived on the network or if additional data is appended to a file that you are reading from. You can call <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesAvailable()</span></code></a> to determine the number of bytes that are currently available for reading. It’s common to use <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesAvailable()</span></code></a> together with the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code></a> signal when programming with asynchronous devices such as <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> , where fragments of data can arrive at arbitrary points in time. <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> emits the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesWritten()</span></code></a> signal every time a payload of data has been written to the device. Use <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesToWrite" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesToWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesToWrite()</span></code></a> to determine the current amount of data waiting to be written.</p>
<p>Certain subclasses of <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> , such as <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> and <a class="reference internal" href="QProcess.html#PySide2.QtCore.QProcess" title="PySide2.QtCore.QProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">QProcess</span></code></a> , are asynchronous. This means that I/O functions such as <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.write" title="PySide2.QtCore.PySide2.QtCore.QIODevice.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> or <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> always return immediately, while communication with the device itself may happen when control goes back to the event loop. <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> provides functions that allow you to force these operations to be performed immediately, while blocking the calling thread and without entering the event loop. This allows <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> subclasses to be used without an event loop, or in a separate thread:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.waitForReadyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.waitForReadyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForReadyRead()</span></code></a> - This function suspends operation in the calling thread until new data is available for reading.</p></li>
<li><p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.waitForBytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.waitForBytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForBytesWritten()</span></code></a> - This function suspends operation in the calling thread until one payload of data has been written to the device.</p></li>
<li><p>waitFor….() - Subclasses of <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> implement blocking functions for device-specific operations. For example, <a class="reference internal" href="QProcess.html#PySide2.QtCore.QProcess" title="PySide2.QtCore.QProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">QProcess</span></code></a> has a function called <a class="reference internal" href="QProcess.html#PySide2.QtCore.PySide2.QtCore.QProcess.waitForStarted" title="PySide2.QtCore.PySide2.QtCore.QProcess.waitForStarted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForStarted()</span></code></a> which suspends operation in the calling thread until the process has started.</p></li>
</ul>
<p>Calling these functions from the main, GUI thread, may cause your user interface to freeze. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gzip</span> <span class="o">=</span> <span class="n">QProcess</span><span class="p">()</span>
<span class="n">gzip</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;gzip&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;-c&quot;</span><span class="p">])</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">gzip</span><span class="o">.</span><span class="n">waitForStarted</span><span class="p">():</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="n">gzip</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;uncompressed data&quot;</span><span class="p">)</span>

<span class="n">compressed</span> <span class="o">=</span> <span class="n">QByteArray</span><span class="p">()</span>
<span class="k">while</span> <span class="n">gzip</span><span class="o">.</span><span class="n">waitForReadyRead</span><span class="p">():</span>
    <span class="n">compressed</span> <span class="o">+=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">readAll</span><span class="p">()</span>
</pre></div>
</div>
<p>By subclassing <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> , you can provide the same interface to your own I/O devices. Subclasses of <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> are only required to implement the protected <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readData" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readData"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readData()</span></code></a> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeData" title="PySide2.QtCore.PySide2.QtCore.QIODevice.writeData"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeData()</span></code></a> functions. <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> uses these functions to implement all its convenience functions, such as <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.getChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.getChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getChar()</span></code></a> , <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine()</span></code></a> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.write" title="PySide2.QtCore.PySide2.QtCore.QIODevice.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> . <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> also handles access control for you, so you can safely assume that the device is opened in write mode if <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeData" title="PySide2.QtCore.PySide2.QtCore.QIODevice.writeData"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeData()</span></code></a> is called.</p>
<p>Some subclasses, such as <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> and <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> , are implemented using a memory buffer for intermediate storing of data. This reduces the number of required device accessing calls, which are often very slow. Buffering makes functions like <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.getChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.getChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getChar()</span></code></a> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.putChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.putChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">putChar()</span></code></a> fast, as they can operate on the memory buffer instead of directly on the device itself. Certain I/O operations, however, don’t work well with a buffer. For example, if several users open the same device and read it character by character, they may end up reading the same data when they meant to read a separate chunk each. For this reason, <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> allows you to bypass any buffering by passing the Unbuffered flag to <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.open" title="PySide2.QtCore.PySide2.QtCore.QIODevice.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> . When subclassing <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> , remember to bypass any buffer you may use when the device is open in Unbuffered mode.</p>
<p>Usually, the incoming data stream from an asynchronous device is fragmented, and chunks of data can arrive at arbitrary points in time. To handle incomplete reads of data structures, use the transaction mechanism implemented by <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> . See <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTransaction()</span></code></a> and related functions for more details.</p>
<p>Some sequential devices support communicating via multiple channels. These channels represent separate streams of data that have the property of independently sequenced delivery. Once the device is opened, you can determine the number of channels by calling the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readChannelCount()</span></code></a> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeChannelCount()</span></code></a> functions. To switch between channels, call <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentReadChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentReadChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setCurrentReadChannel()</span></code></a> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentWriteChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentWriteChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setCurrentWriteChannel()</span></code></a> , respectively. <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> also provides additional signals to handle asynchronous communication on a per-channel basis.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="QBuffer.html#PySide2.QtCore.QBuffer" title="PySide2.QtCore.QBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QBuffer</span></code></a>  <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a>  <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide2.QtCore.QIODevice">
<em class="property">class </em><code class="sig-name descname">QIODevice</code><a class="headerlink" href="#PySide2.QtCore.QIODevice" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>QIODevice(parent)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param parent</dt>
<dd class="field-odd"><p><a class="reference internal" href="QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">QObject</span></code></a></p>
</dd>
</dl>
</div></blockquote>
<p>Constructs a <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> object.</p>
<p>Constructs a <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> object with the given <code class="docutils literal notranslate"><span class="pre">parent</span></code> .</p>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.OpenModeFlag">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">OpenModeFlag</code><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.OpenModeFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum is used with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.open" title="PySide2.QtCore.PySide2.QtCore.QIODevice.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> to describe the mode in which a device is opened. It is also returned by <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.openMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.openMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">openMode()</span></code></a> .</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 4%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QIODevice.NotOpen</p></td>
<td><p>The device is not open.</p></td>
</tr>
<tr class="row-odd"><td><p>QIODevice.ReadOnly</p></td>
<td><p>The device is open for reading.</p></td>
</tr>
<tr class="row-even"><td><p>QIODevice.WriteOnly</p></td>
<td><p>The device is open for writing. Note that, for file-system subclasses (e.g. <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> ), this mode implies Truncate unless combined with , Append or .</p></td>
</tr>
<tr class="row-odd"><td><p>QIODevice.ReadWrite</p></td>
<td><p>The device is open for reading and writing.</p></td>
</tr>
<tr class="row-even"><td><p>QIODevice.Append</p></td>
<td><p>The device is opened in append mode so that all data is written to the end of the file.</p></td>
</tr>
<tr class="row-odd"><td><p>QIODevice.Truncate</p></td>
<td><p>If possible, the device is truncated before it is opened. All earlier contents of the device are lost.</p></td>
</tr>
<tr class="row-even"><td><p>QIODevice.Text</p></td>
<td><p>When reading, the end-of-line terminators are translated to ‘\n’. When writing, the end-of-line terminators are translated to the local encoding, for example ‘\r\n’ for Win32.</p></td>
</tr>
<tr class="row-odd"><td><p>QIODevice.Unbuffered</p></td>
<td><p>Any buffer in the device is bypassed.</p></td>
</tr>
<tr class="row-even"><td><p>QIODevice.NewOnly</p></td>
<td><p>Fail if the file to be opened already exists. Create and open the file only if it does not exist. There is a guarantee from the operating system that you are the only one creating and opening the file. Note that this mode implies , and combining it with is allowed. This flag currently only affects <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> . Other classes might use this flag in the future, but until then using this flag with any classes other than <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> may result in undefined behavior. (since Qt 5.11)</p></td>
</tr>
<tr class="row-odd"><td><p>QIODevice.ExistingOnly</p></td>
<td><p>Fail if the file to be opened does not exist. This flag must be specified alongside , , or . Note that using this flag with alone is redundant, as already fails when the file does not exist. This flag currently only affects <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> . Other classes might use this flag in the future, but until then using this flag with any classes other than <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> may result in undefined behavior. (since Qt 5.11)</p></td>
</tr>
</tbody>
</table>
<p>Certain flags, such as <code class="docutils literal notranslate"><span class="pre">Unbuffered</span></code> and <code class="docutils literal notranslate"><span class="pre">Truncate</span></code> , are meaningless when used with some subclasses. Some of these restrictions are implied by the type of device that is represented by a subclass. In other cases, the restriction may be due to the implementation, or may be imposed by the underlying platform; for example, <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide2.QtNetwork.QTcpSocket" title="PySide2.QtNetwork.QTcpSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTcpSocket</span></code></a> does not support <code class="docutils literal notranslate"><span class="pre">Unbuffered</span></code> mode, and limitations in the native API prevent <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> from supporting <code class="docutils literal notranslate"><span class="pre">Unbuffered</span></code> on Windows.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.aboutToClose">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">aboutToClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.aboutToClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.atEnd">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">atEnd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.atEnd" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the current read and write position is at the end of the device (i.e. there is no more data available for reading on the device); otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<p>For some devices, can return true even though there is more data to read. This special case only applies to devices that generate data in direct response to you calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> (e.g., <code class="docutils literal notranslate"><span class="pre">/dev</span></code> or <code class="docutils literal notranslate"><span class="pre">/proc</span></code> files on Unix and <span class="xref std std-ref">macOS</span> , or console input / <code class="docutils literal notranslate"><span class="pre">stdin</span></code> on all platforms).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesAvailable()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isSequential()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">bytesAvailable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
<p>Returns the number of bytes that are available for reading. This function is commonly used with sequential devices to determine the number of bytes to allocate in a buffer before reading.</p>
<p>Subclasses that reimplement this function must call the base implementation in order to include the size of the buffer of <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> . Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bytesAvailable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">QIODevice</span><span class="o">.</span><span class="n">bytesAvailable</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesToWrite" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesToWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesToWrite()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isSequential()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesToWrite">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">bytesToWrite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesToWrite" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
<p>For buffered devices, this function returns the number of bytes waiting to be written. For devices with no buffer, this function returns 0.</p>
<p>Subclasses that reimplement this function must call the base implementation in order to include the size of the buffer of <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesAvailable()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesWritten()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isSequential()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">bytesWritten</code><span class="sig-paren">(</span><em class="sig-param">bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bytes</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.canReadLine">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">canReadLine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.canReadLine" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if a complete line of data can be read from the device; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<p>Note that unbuffered devices, which have no way of determining what can be read, always return false.</p>
<p>This function is often called in conjunction with the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code></a> signal.</p>
<p>Subclasses that reimplement this function must call the base implementation in order to include the contents of the <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> ‘s buffer. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">canReadLine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">QIODevice</span><span class="o">.</span><span class="n">canReadLine</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.channelBytesWritten">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">channelBytesWritten</code><span class="sig-paren">(</span><em class="sig-param">channel</em>, <em class="sig-param">bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.channelBytesWritten" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>channel</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p></li>
<li><p><strong>bytes</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.channelReadyRead">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">channelReadyRead</code><span class="sig-paren">(</span><em class="sig-param">channel</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.channelReadyRead" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>channel</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.close">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.close" title="Permalink to this definition">¶</a></dt>
<dd><p>First emits <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.aboutToClose" title="PySide2.QtCore.PySide2.QtCore.QIODevice.aboutToClose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aboutToClose()</span></code></a> , then closes the device and sets its <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code> to <code class="xref py py-attr docutils literal notranslate"><span class="pre">NotOpen</span></code> . The error string is also reset.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setOpenMode()</span></code></a>  <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">commitTransaction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Completes a read transaction.</p>
<p>For sequential devices, all data recorded in the internal buffer during the transaction will be discarded.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTransaction()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rollbackTransaction()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.currentReadChannel">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">currentReadChannel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.currentReadChannel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Returns the index of the current read channel.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentReadChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentReadChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setCurrentReadChannel()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readChannelCount()</span></code></a>  <a class="reference internal" href="QProcess.html#PySide2.QtCore.QProcess" title="PySide2.QtCore.QProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">QProcess</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.currentWriteChannel">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">currentWriteChannel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.currentWriteChannel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Returns the the index of the current write channel.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentWriteChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentWriteChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setCurrentWriteChannel()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeChannelCount()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.errorString">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">errorString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.errorString" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>unicode</p>
</dd>
</dl>
<p>Returns a human-readable description of the last device error that occurred.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setErrorString" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setErrorString"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setErrorString()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.getChar">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">getChar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.getChar" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Reads one character from the device and stores it in <code class="docutils literal notranslate"><span class="pre">c</span></code> . If <code class="docutils literal notranslate"><span class="pre">c</span></code> is 0, the character is discarded. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.putChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.putChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">putChar()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.ungetChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.ungetChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ungetChar()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.isOpen">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">isOpen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isOpen" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the device is open; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> . A device is open if it can be read from and/or written to. By default, this function returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.openMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.openMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">openMode()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">NotOpen</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.openMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.openMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">openMode()</span></code></a>  <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.isReadable">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">isReadable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isReadable" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if data can be read from the device; otherwise returns false. Use <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesAvailable()</span></code></a> to determine how many bytes can be read.</p>
<p>This is a convenience function which checks if the <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code> of the device contains the <code class="xref py py-attr docutils literal notranslate"><span class="pre">ReadOnly</span></code> flag.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.openMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.openMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">openMode()</span></code></a>  <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">isSequential</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if this device is sequential; otherwise returns false.</p>
<p>Sequential devices, as opposed to a random-access devices, have no concept of a start, an end, a size, or a current position, and they do not support seeking. You can only read from the device when it reports that data is available. The most common example of a sequential device is a network socket. On Unix, special files such as /dev/zero and fifo pipes are sequential.</p>
<p>Regular files, on the other hand, do support random access. They have both a size and a current position, and they also support seeking backwards and forwards in the data stream. Regular files are non-sequential.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesAvailable()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.isTextModeEnabled">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">isTextModeEnabled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isTextModeEnabled" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Text</span></code> flag is enabled; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setTextModeEnabled" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setTextModeEnabled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setTextModeEnabled()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.isTransactionStarted">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">isTransactionStarted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isTransactionStarted" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if a transaction is in progress on the device, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTransaction()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.isWritable">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">isWritable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isWritable" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if data can be written to the device; otherwise returns false.</p>
<p>This is a convenience function which checks if the <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code> of the device contains the <code class="xref py py-attr docutils literal notranslate"><span class="pre">WriteOnly</span></code> flag.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.openMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.openMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">openMode()</span></code></a>  <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.open">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">mode</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.open" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mode</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Opens the device and sets its <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code> to <code class="docutils literal notranslate"><span class="pre">mode</span></code> . Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if successful; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> . This function should be called from any reimplementations of or other functions that open the device.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.openMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.openMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">openMode()</span></code></a>  <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.openMode">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">openMode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.openMode" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</dd>
</dl>
<p>Returns the mode in which the device has been opened; i.e. <code class="xref py py-attr docutils literal notranslate"><span class="pre">ReadOnly</span></code> or <code class="xref py py-attr docutils literal notranslate"><span class="pre">WriteOnly</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setOpenMode()</span></code></a>  <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.peek">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">peek</code><span class="sig-paren">(</span><em class="sig-param">maxlen</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.peek" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxlen</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a></p>
</dd>
</dl>
<p>This is an overloaded function.</p>
<p>Peeks at most <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes from the device, returning the data peeked as a <a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a> .</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">isExeFile</span><span class="p">(</span><span class="n">file_</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">file_</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;MZ&quot;</span>
</pre></div>
</div>
<p>This function has no way of reporting errors; returning an empty <a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a> can mean either that no data was currently available for peeking, or that an error occurred.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.pos">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">pos</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.pos" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
<p>For random-access devices, this function returns the position that data is written to or read from. For sequential devices or closed devices, where there is no concept of a “current position”, 0 is returned.</p>
<p>The current read/write position of the device is maintained internally by <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> , so reimplementing this function is not necessary. When subclassing <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> , use <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.seek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a> to notify <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> about changes in the device position.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isSequential()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.seek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.putChar">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">putChar</code><span class="sig-paren">(</span><em class="sig-param">c</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.putChar" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>c</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">char</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Writes the character <code class="docutils literal notranslate"><span class="pre">c</span></code> to the device. Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> on success; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.write" title="PySide2.QtCore.PySide2.QtCore.QIODevice.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.getChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.getChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getChar()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.ungetChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.ungetChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ungetChar()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.read">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param">maxlen</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxlen</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a></p>
</dd>
</dl>
<p>This is an overloaded function.</p>
<p>Reads at most <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes from the device, and returns the data read as a <a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a> .</p>
<p>This function has no way of reporting errors; returning an empty <a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a> can mean either that no data was currently available for reading, or that an error occurred.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.readAll">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">readAll</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readAll" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a></p>
</dd>
</dl>
<p>Reads all remaining data from the device, and returns it as a byte array.</p>
<p>This function has no way of reporting errors; returning an empty <a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a> can mean either that no data was currently available for reading, or that an error occurred.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">readChannelCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Returns the number of available read channels if the device is open; otherwise returns 0.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeChannelCount()</span></code></a>  <a class="reference internal" href="QProcess.html#PySide2.QtCore.QProcess" title="PySide2.QtCore.QProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">QProcess</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelFinished">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">readChannelFinished</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelFinished" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.readData">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">readData</code><span class="sig-paren">(</span><em class="sig-param">maxlen</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxlen</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>PyObject</p>
</dd>
</dl>
<p>Reads up to <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes from the device into <code class="docutils literal notranslate"><span class="pre">data</span></code> , and returns the number of bytes read or -1 if an error occurred.</p>
<p>If there are no bytes to be read and there can never be more bytes available (examples include socket closed, pipe closed, sub-process finished), this function returns -1.</p>
<p>This function is called by <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> . Reimplement this function when creating a subclass of <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> .</p>
<p>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for <a class="reference internal" href="QDataStream.html#PySide2.QtCore.QDataStream" title="PySide2.QtCore.QDataStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">QDataStream</span></code></a> to be able to operate on the class. <a class="reference internal" href="QDataStream.html#PySide2.QtCore.QDataStream" title="PySide2.QtCore.QDataStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">QDataStream</span></code></a> assumes all the requested information was read and therefore does not retry reading if there was a problem.</p>
<p>This function might be called with a maxSize of 0, which can be used to perform post-reading operations.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeData" title="PySide2.QtCore.PySide2.QtCore.QIODevice.writeData"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeData()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">readLine</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">maxlen=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxlen</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a></p>
</dd>
</dl>
<p>This is an overloaded function.</p>
<p>Reads a line from the device, but no more than <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> characters, and returns the result as a byte array.</p>
<p>This function has no way of reporting errors; returning an empty <a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a> can mean either that no data was currently available for reading, or that an error occurred.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.readLineData">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">readLineData</code><span class="sig-paren">(</span><em class="sig-param">maxlen</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLineData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxlen</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>PyObject</p>
</dd>
</dl>
<p>Reads up to <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> characters into <code class="docutils literal notranslate"><span class="pre">data</span></code> and returns the number of characters read.</p>
<p>This function is called by <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine()</span></code></a> , and provides its base implementation, using <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.getChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.getChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getChar()</span></code></a> . Buffered devices can improve the performance of <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine()</span></code></a> by reimplementing this function.</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine()</span></code></a> appends a ‘\0’ byte to <code class="docutils literal notranslate"><span class="pre">data</span></code> ; does not need to do this.</p>
<p>If you reimplement this function, be careful to return the correct value: it should return the number of bytes read in this line, including the terminating newline, or 0 if there is no line to be read at this point. If an error occurs, it should return -1 if and only if no bytes were read. Reading past EOF is considered an error.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">readyRead</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.reset">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.reset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Seeks to the start of input for random-access devices. Returns true on success; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> (for example, if the device is not open).</p>
<p>Note that when using a <a class="reference internal" href="QTextStream.html#PySide2.QtCore.QTextStream" title="PySide2.QtCore.QTextStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTextStream</span></code></a> on a <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> , calling on the <a class="reference internal" href="QFile.html#PySide2.QtCore.QFile" title="PySide2.QtCore.QFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">QFile</span></code></a> will not have the expected result because <a class="reference internal" href="QTextStream.html#PySide2.QtCore.QTextStream" title="PySide2.QtCore.QTextStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTextStream</span></code></a> buffers the file. Use the <a class="reference internal" href="QTextStream.html#PySide2.QtCore.PySide2.QtCore.QTextStream.seek" title="PySide2.QtCore.PySide2.QtCore.QTextStream.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a> function instead.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.seek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">rollbackTransaction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Rolls back a read transaction.</p>
<p>Restores the input stream to the point of the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTransaction()</span></code></a> call. This function is commonly used to rollback the transaction when an incomplete read was detected prior to committing the transaction.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTransaction()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commitTransaction()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.seek">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">seek</code><span class="sig-paren">(</span><em class="sig-param">pos</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.seek" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pos</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>For random-access devices, this function sets the current position to <code class="docutils literal notranslate"><span class="pre">pos</span></code> , returning true on success, or false if an error occurred. For sequential devices, the default behavior is to produce a warning and return false.</p>
<p>When subclassing <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> , you must call at the start of your function to ensure integrity with <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> ‘s built-in buffer.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.pos" title="PySide2.QtCore.PySide2.QtCore.QIODevice.pos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pos()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isSequential()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentReadChannel">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">setCurrentReadChannel</code><span class="sig-paren">(</span><em class="sig-param">channel</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentReadChannel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>channel</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Sets the current read channel of the <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> to the given <code class="docutils literal notranslate"><span class="pre">channel</span></code> . The current input channel is used by the functions <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> , <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readAll" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readAll"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readAll()</span></code></a> , <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readLine" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readLine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readLine()</span></code></a> , and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.getChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.getChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getChar()</span></code></a> . It also determines which channel triggers <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> to emit <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code></a> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.currentReadChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.currentReadChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">currentReadChannel()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readChannelCount()</span></code></a>  <a class="reference internal" href="QProcess.html#PySide2.QtCore.QProcess" title="PySide2.QtCore.QProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">QProcess</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentWriteChannel">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">setCurrentWriteChannel</code><span class="sig-paren">(</span><em class="sig-param">channel</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setCurrentWriteChannel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>channel</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Sets the current write channel of the <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> to the given <code class="docutils literal notranslate"><span class="pre">channel</span></code> . The current output channel is used by the functions <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.write" title="PySide2.QtCore.PySide2.QtCore.QIODevice.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> , <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.putChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.putChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">putChar()</span></code></a> . It also determines which channel triggers <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> to emit <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesWritten()</span></code></a> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.currentWriteChannel" title="PySide2.QtCore.PySide2.QtCore.QIODevice.currentWriteChannel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">currentWriteChannel()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeChannelCount()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.setErrorString">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">setErrorString</code><span class="sig-paren">(</span><em class="sig-param">errorString</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setErrorString" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>errorString</strong> – unicode</p>
</dd>
</dl>
<p>Sets the human readable description of the last device error that occurred to <code class="docutils literal notranslate"><span class="pre">str</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.errorString" title="PySide2.QtCore.PySide2.QtCore.QIODevice.errorString"><code class="xref py py-meth docutils literal notranslate"><span class="pre">errorString()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">setOpenMode</code><span class="sig-paren">(</span><em class="sig-param">openMode</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>openMode</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</dd>
</dl>
<p>Sets the <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code> of the device to <code class="docutils literal notranslate"><span class="pre">openMode</span></code> . Call this function to set the open mode if the flags change after the device has been opened.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.openMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.openMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">openMode()</span></code></a>  <code class="xref py py-class docutils literal notranslate"><span class="pre">OpenMode</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.setTextModeEnabled">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">setTextModeEnabled</code><span class="sig-paren">(</span><em class="sig-param">enabled</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setTextModeEnabled" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>enabled</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>If <code class="docutils literal notranslate"><span class="pre">enabled</span></code> is true, this function sets the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Text</span></code> flag on the device; otherwise the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Text</span></code> flag is removed. This feature is useful for classes that provide custom end-of-line handling on a <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> .</p>
<p>The IO device should be opened before calling this function.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isTextModeEnabled" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isTextModeEnabled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isTextModeEnabled()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.open" title="PySide2.QtCore.PySide2.QtCore.QIODevice.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode" title="PySide2.QtCore.PySide2.QtCore.QIODevice.setOpenMode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setOpenMode()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.size">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
<p>For open random-access devices, this function returns the size of the device. For open sequential devices, <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesAvailable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesAvailable()</span></code></a> is returned.</p>
<p>If the device is closed, the size returned will not reflect the actual size of the device.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential" title="PySide2.QtCore.PySide2.QtCore.QIODevice.isSequential"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isSequential()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.pos" title="PySide2.QtCore.PySide2.QtCore.QIODevice.pos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pos()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.skip">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">skip</code><span class="sig-paren">(</span><em class="sig-param">maxSize</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.skip" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxSize</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
<p>Skips up to <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes from the device. Returns the number of bytes actually skipped, or -1 on error.</p>
<p>This function does not wait and only discards the data that is already available for reading.</p>
<p>If the device is opened in text mode, end-of-line terminators are translated to ‘\n’ symbols and count as a single byte identically to the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.peek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.peek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peek()</span></code></a> behavior.</p>
<p>This function works for all devices, including sequential ones that cannot <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.seek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a> . It is optimized to skip unwanted data after a <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.peek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.peek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peek()</span></code></a> call.</p>
<p>For random-access devices, can be used to seek forward from the current position. Negative <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> values are not allowed.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.peek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.peek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">peek()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.seek" title="PySide2.QtCore.PySide2.QtCore.QIODevice.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">startTransaction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.startTransaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a new read transaction on the device.</p>
<p>Defines a restorable point within the sequence of read operations. For sequential devices, read data will be duplicated internally to allow recovery in case of incomplete reads. For random-access devices, this function saves the current position. Call <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commitTransaction()</span></code></a> or <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rollbackTransaction()</span></code></a> to finish the transaction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Nesting transactions is not supported.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.commitTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">commitTransaction()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction" title="PySide2.QtCore.PySide2.QtCore.QIODevice.rollbackTransaction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rollbackTransaction()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.ungetChar">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">ungetChar</code><span class="sig-paren">(</span><em class="sig-param">c</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.ungetChar" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>c</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">char</span></code></p>
</dd>
</dl>
<p>Puts the character <code class="docutils literal notranslate"><span class="pre">c</span></code> back into the device, and decrements the current position unless the position is 0. This function is usually called to “undo” a <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.getChar" title="PySide2.QtCore.PySide2.QtCore.QIODevice.getChar"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getChar()</span></code></a> operation, such as when writing a backtracking parser.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">c</span></code> was not previously read from the device, the behavior is undefined.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is not available while a transaction is in progress.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.waitForBytesWritten">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">waitForBytesWritten</code><span class="sig-paren">(</span><em class="sig-param">msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.waitForBytesWritten" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msecs</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>For buffered devices, this function waits until a payload of buffered written data has been written to the device and the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesWritten()</span></code></a> signal has been emitted, or until <code class="docutils literal notranslate"><span class="pre">msecs</span></code> milliseconds have passed. If msecs is -1, this function will not time out. For unbuffered devices, it returns immediately.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if a payload of data was written to the device; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> (i.e. if the operation timed out, or if an error occurred).</p>
<p>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread.</p>
<p>If called from within a slot connected to the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesWritten()</span></code></a> signal, <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.bytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytesWritten()</span></code></a> will not be reemitted.</p>
<p>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Calling this function from the main (GUI) thread might cause your user interface to freeze.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.waitForReadyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.waitForReadyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForReadyRead()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.waitForReadyRead">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">waitForReadyRead</code><span class="sig-paren">(</span><em class="sig-param">msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.waitForReadyRead" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msecs</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Blocks until new data is available for reading and the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code></a> signal has been emitted, or until <code class="docutils literal notranslate"><span class="pre">msecs</span></code> milliseconds have passed. If msecs is -1, this function will not time out.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if new data is available for reading; otherwise returns false (if the operation timed out or if an error occurred).</p>
<p>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread.</p>
<p>If called from within a slot connected to the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code></a> signal, <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readyRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readyRead()</span></code></a> will not be reemitted.</p>
<p>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Calling this function from the main (GUI) thread might cause your user interface to freeze.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.waitForBytesWritten" title="PySide2.QtCore.PySide2.QtCore.QIODevice.waitForBytesWritten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">waitForBytesWritten()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.write">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.write" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> – <a class="reference internal" href="QByteArray.html#PySide2.QtCore.QByteArray" title="PySide2.QtCore.QByteArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">QByteArray</span></code></a></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">writeChannelCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeChannelCount" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Returns the number of available write channels if the device is open; otherwise returns 0.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount" title="PySide2.QtCore.PySide2.QtCore.QIODevice.readChannelCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readChannelCount()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QIODevice.writeData">
<code class="sig-prename descclassname">PySide2.QtCore.QIODevice.</code><code class="sig-name descname">writeData</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">len</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.writeData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> – str</p></li>
<li><p><strong>len</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">qint64</span></code></p>
</dd>
</dl>
<p>Writes up to <code class="docutils literal notranslate"><span class="pre">maxSize</span></code> bytes from <code class="docutils literal notranslate"><span class="pre">data</span></code> to the device. Returns the number of bytes written, or -1 if an error occurred.</p>
<p>This function is called by <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> . Reimplement this function when creating a subclass of <a class="reference internal" href="#PySide2.QtCore.QIODevice" title="PySide2.QtCore.QIODevice"><code class="xref py py-class docutils literal notranslate"><span class="pre">QIODevice</span></code></a> .</p>
<p>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for <a class="reference internal" href="QDataStream.html#PySide2.QtCore.QDataStream" title="PySide2.QtCore.QDataStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">QDataStream</span></code></a> to be able to operate on the class. <a class="reference internal" href="QDataStream.html#PySide2.QtCore.QDataStream" title="PySide2.QtCore.QDataStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">QDataStream</span></code></a> assumes all the information was written and therefore does not retry writing if there was a problem.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.read" title="PySide2.QtCore.PySide2.QtCore.QIODevice.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QIODevice.write" title="PySide2.QtCore.PySide2.QtCore.QIODevice.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2019 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>