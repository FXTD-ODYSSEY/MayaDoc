
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>QThread &#8212; Qt for Python</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <link rel="search" title="Search" href="../../search.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'https://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head><body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="https://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="https://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        
                        <li><a href="../../index.html">Qt for Python 5.13.0</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QThread</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#virtual-functions">Virtual functions</a></li>
<li><a class="reference internal" href="#slots">Slots</a></li>
<li><a class="reference internal" href="#static-functions">Static functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a><ul>
<li><a class="reference internal" href="#managing-threads">Managing Threads</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-PySide2.QtCore"></span><div class="section" id="qthread">
<span id="id1"></span><h1>QThread<a class="headerlink" href="#qthread" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> class provides a platform-independent way to manage threads. <a class="reference internal" href="#more">More</a>…</p>
</div></blockquote>
<div class="graphviz"><img src="../../_images/inheritance-548e6663ddc8d1f70944d962562ed8ea6bb5114c.png" alt="Inheritance diagram of PySide2.QtCore.QThread" usemap="#inheritance0d9007d598" class="inheritance graphviz" /></div>
<map id="inheritance0d9007d598" name="inheritance0d9007d598">
<area shape="rect" id="node1" href="#PySide2.QtCore.QThread" title="QtCore.QThread" alt="" coords="176,5,301,31"/>
<area shape="rect" id="node2" href="QObject.html#PySide2.QtCore.QObject" title="QtCore.QObject" alt="" coords="5,5,128,31"/>
</map><div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.eventDispatcher" title="PySide2.QtCore.PySide2.QtCore.QThread.eventDispatcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eventDispatcher</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.exec_" title="PySide2.QtCore.PySide2.QtCore.QThread.exec_"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.exit" title="PySide2.QtCore.PySide2.QtCore.QThread.exit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exit</span></code></a> ([retcode=0])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.isFinished" title="PySide2.QtCore.PySide2.QtCore.QThread.isFinished"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isFinished</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.isInterruptionRequested" title="PySide2.QtCore.PySide2.QtCore.QThread.isInterruptionRequested"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isInterruptionRequested</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.isRunning" title="PySide2.QtCore.PySide2.QtCore.QThread.isRunning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isRunning</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.loopLevel" title="PySide2.QtCore.PySide2.QtCore.QThread.loopLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loopLevel</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.priority" title="PySide2.QtCore.PySide2.QtCore.QThread.priority"><code class="xref py py-meth docutils literal notranslate"><span class="pre">priority</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.requestInterruption" title="PySide2.QtCore.PySide2.QtCore.QThread.requestInterruption"><code class="xref py py-meth docutils literal notranslate"><span class="pre">requestInterruption</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setEventDispatcher" title="PySide2.QtCore.PySide2.QtCore.QThread.setEventDispatcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setEventDispatcher</span></code></a> (eventDispatcher)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setPriority" title="PySide2.QtCore.PySide2.QtCore.QThread.setPriority"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPriority</span></code></a> (priority)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setStackSize" title="PySide2.QtCore.PySide2.QtCore.QThread.setStackSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setStackSize</span></code></a> (stackSize)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.stackSize" title="PySide2.QtCore.PySide2.QtCore.QThread.stackSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stackSize</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.wait" title="PySide2.QtCore.PySide2.QtCore.QThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait</span></code></a> ([time=ULONG_MAX])</p></li>
</ul>
</div>
</div>
<div class="section" id="virtual-functions">
<h3>Virtual functions<a class="headerlink" href="#virtual-functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run</span></code></a> ()</p></li>
</ul>
</div>
</div>
<div class="section" id="slots">
<h3>Slots<a class="headerlink" href="#slots" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.quit" title="PySide2.QtCore.PySide2.QtCore.QThread.quit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quit</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="PySide2.QtCore.PySide2.QtCore.QThread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start</span></code></a> ([priority=InheritPriority])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="PySide2.QtCore.PySide2.QtCore.QThread.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate</span></code></a> ()</p></li>
</ul>
</div>
</div>
<div class="section" id="static-functions">
<h3>Static functions<a class="headerlink" href="#static-functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.currentThread" title="PySide2.QtCore.PySide2.QtCore.QThread.currentThread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">currentThread</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.idealThreadCount" title="PySide2.QtCore.PySide2.QtCore.QThread.idealThreadCount"><code class="xref py py-meth docutils literal notranslate"><span class="pre">idealThreadCount</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.msleep" title="PySide2.QtCore.PySide2.QtCore.QThread.msleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">msleep</span></code></a> (arg__1)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled" title="PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setTerminationEnabled</span></code></a> ([enabled=true])</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.sleep" title="PySide2.QtCore.PySide2.QtCore.QThread.sleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sleep</span></code></a> (arg__1)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.usleep" title="PySide2.QtCore.PySide2.QtCore.QThread.usleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">usleep</span></code></a> (arg__1)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.yieldCurrentThread" title="PySide2.QtCore.PySide2.QtCore.QThread.yieldCurrentThread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">yieldCurrentThread</span></code></a> ()</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote id="more">
<div><p>A <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> object manages one thread of control within the program. QThreads begin executing in <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> . By default, <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> starts the event loop by calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec()</span></code> and runs a Qt event loop inside the thread.</p>
<p>You can use worker objects by moving them to the thread using <a class="reference internal" href="QObject.html#PySide2.QtCore.PySide2.QtCore.QObject.moveToThread" title="PySide2.QtCore.PySide2.QtCore.QObject.moveToThread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">moveToThread()</span></code></a> .</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Worker</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QObject</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="n">public</span> <span class="n">slots</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">doWork</span><span class="p">(</span><span class="n">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">parameter</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">QString</span> <span class="n">result</span><span class="p">;</span>
        <span class="o">/*</span> <span class="o">...</span> <span class="n">here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">expensive</span> <span class="ow">or</span> <span class="n">blocking</span> <span class="n">operation</span> <span class="o">...</span> <span class="o">*/</span>
        <span class="n">emit</span> <span class="n">resultReady</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

<span class="n">signals</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">resultReady</span><span class="p">(</span><span class="n">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Controller</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QObject</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>
    <span class="n">QThread</span> <span class="n">workerThread</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
    <span class="n">Controller</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Worker</span><span class="p">;</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">moveToThread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workerThread</span><span class="p">);</span>
        <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">workerThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QThread</span><span class="p">::</span><span class="n">finished</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QObject</span><span class="p">::</span><span class="n">deleteLater</span><span class="p">);</span>
        <span class="n">connect</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Controller</span><span class="p">::</span><span class="n">operate</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Worker</span><span class="p">::</span><span class="n">doWork</span><span class="p">);</span>
        <span class="n">connect</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Worker</span><span class="p">::</span><span class="n">resultReady</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Controller</span><span class="p">::</span><span class="n">handleResults</span><span class="p">);</span>
        <span class="n">workerThread</span><span class="o">.</span><span class="n">start</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Controller</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">workerThread</span><span class="o">.</span><span class="n">quit</span><span class="p">();</span>
        <span class="n">workerThread</span><span class="o">.</span><span class="n">wait</span><span class="p">();</span>
    <span class="p">}</span>
<span class="n">public</span> <span class="n">slots</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">handleResults</span><span class="p">(</span><span class="n">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="n">signals</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">operate</span><span class="p">(</span><span class="n">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The code inside the Worker’s slot would then execute in a separate thread. However, you are free to connect the Worker’s slots to any signal, from any object, in any thread. It is safe to connect signals and slots across different threads, thanks to a mechanism called <code class="xref py py-attr docutils literal notranslate"><span class="pre">queued</span> <span class="pre">connections</span></code> .</p>
<p>Another way to make code run in a separate thread, is to subclass <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> and reimplement <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> . For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WorkerThread</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QThread</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>
    <span class="n">void</span> <span class="n">run</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span>
        <span class="n">QString</span> <span class="n">result</span><span class="p">;</span>
        <span class="o">/*</span> <span class="o">...</span> <span class="n">here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">expensive</span> <span class="ow">or</span> <span class="n">blocking</span> <span class="n">operation</span> <span class="o">...</span> <span class="o">*/</span>
        <span class="n">emit</span> <span class="n">resultReady</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="n">signals</span><span class="p">:</span>
    <span class="n">void</span> <span class="n">resultReady</span><span class="p">(</span><span class="n">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">void</span> <span class="n">MyObject</span><span class="p">::</span><span class="n">startWorkInAThread</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">WorkerThread</span> <span class="o">*</span><span class="n">workerThread</span> <span class="o">=</span> <span class="n">new</span> <span class="n">WorkerThread</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">workerThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">WorkerThread</span><span class="p">::</span><span class="n">resultReady</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyObject</span><span class="p">::</span><span class="n">handleResults</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">workerThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">WorkerThread</span><span class="p">::</span><span class="n">finished</span><span class="p">,</span> <span class="n">workerThread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QObject</span><span class="p">::</span><span class="n">deleteLater</span><span class="p">);</span>
    <span class="n">workerThread</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In that example, the thread will exit after the run function has returned. There will not be any event loop running in the thread unless you call <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec()</span></code> .</p>
<p>It is important to remember that a <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> instance <code class="xref py py-class docutils literal notranslate"><span class="pre">lives</span> <span class="pre">in</span></code> the old thread that instantiated it, not in the new thread that calls <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> . This means that all of <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> ‘s queued slots and <a class="reference internal" href="QMetaObject.html#PySide2.QtCore.PySide2.QtCore.QMetaObject.invokeMethod" title="PySide2.QtCore.PySide2.QtCore.QMetaObject.invokeMethod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">invoked</span> <span class="pre">methods</span></code></a> will execute in the old thread. Thus, a developer who wishes to invoke slots in the new thread must use the worker-object approach; new slots should not be implemented directly into a subclassed <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> .</p>
<p>Unlike queued slots or invoked methods, methods called directly on the <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> object will execute in the thread that calls the method. When subclassing <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> , keep in mind that the constructor executes in the old thread while <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> executes in the new thread. If a member variable is accessed from both functions, then the variable is accessed from two different threads. Check that it is safe to do so.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Care must be taken when interacting with objects across different threads. See Synchronizing Threads for details.</p>
</div>
</div></blockquote>
<div class="section" id="managing-threads">
<span id="pyside2-qtcore-qthread-managing-threads"></span><h3>Managing Threads<a class="headerlink" href="#managing-threads" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> will notifiy you via a signal when the thread is <code class="xref py py-meth docutils literal notranslate"><span class="pre">started()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">finished()</span></code> , or you can use <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.isFinished" title="PySide2.QtCore.PySide2.QtCore.QThread.isFinished"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isFinished()</span></code></a> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.isRunning" title="PySide2.QtCore.PySide2.QtCore.QThread.isRunning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isRunning()</span></code></a> to query the state of the thread.</p>
<p>You can stop the thread by calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.exit" title="PySide2.QtCore.PySide2.QtCore.QThread.exit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exit()</span></code></a> or <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.quit" title="PySide2.QtCore.PySide2.QtCore.QThread.quit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quit()</span></code></a> . In extreme cases, you may want to forcibly <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="PySide2.QtCore.PySide2.QtCore.QThread.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> an executing thread. However, doing so is dangerous and discouraged. Please read the documentation for <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="PySide2.QtCore.PySide2.QtCore.QThread.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled" title="PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setTerminationEnabled()</span></code></a> for detailed information.</p>
<p>From Qt 4.8 onwards, it is possible to deallocate objects that live in a thread that has just ended, by connecting the <code class="xref py py-meth docutils literal notranslate"><span class="pre">finished()</span></code> signal to <a class="reference internal" href="QObject.html#PySide2.QtCore.PySide2.QtCore.QObject.deleteLater" title="PySide2.QtCore.PySide2.QtCore.QObject.deleteLater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">deleteLater()</span></code></a> .</p>
<p>Use <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.wait" title="PySide2.QtCore.PySide2.QtCore.QThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> to block the calling thread, until the other thread has finished execution (or until a specified time has passed).</p>
<p><a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> also provides static, platform independent sleep functions: <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.sleep" title="PySide2.QtCore.PySide2.QtCore.QThread.sleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sleep()</span></code></a> , <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.msleep" title="PySide2.QtCore.PySide2.QtCore.QThread.msleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">msleep()</span></code></a> , and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.usleep" title="PySide2.QtCore.PySide2.QtCore.QThread.usleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">usleep()</span></code></a> allow full second, millisecond, and microsecond resolution respectively. These functions were made public in Qt 5.0.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.wait" title="PySide2.QtCore.PySide2.QtCore.QThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> and the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.sleep" title="PySide2.QtCore.PySide2.QtCore.QThread.sleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sleep()</span></code></a> functions should be unnecessary in general, since Qt is an event-driven framework. Instead of <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.wait" title="PySide2.QtCore.PySide2.QtCore.QThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> , consider listening for the <code class="xref py py-meth docutils literal notranslate"><span class="pre">finished()</span></code> signal. Instead of the <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.sleep" title="PySide2.QtCore.PySide2.QtCore.QThread.sleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sleep()</span></code></a> functions, consider using <a class="reference internal" href="QTimer.html#PySide2.QtCore.QTimer" title="PySide2.QtCore.QTimer"><code class="xref py py-class docutils literal notranslate"><span class="pre">QTimer</span></code></a> .</p>
</div>
<p>The static functions <code class="xref py py-meth docutils literal notranslate"><span class="pre">currentThreadId()</span></code> and <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.currentThread" title="PySide2.QtCore.PySide2.QtCore.QThread.currentThread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">currentThread()</span></code></a> return identifiers for the currently executing thread. The former returns a platform specific ID for the thread; the latter returns a <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> pointer.</p>
<p>To choose the name that your thread will be given (as identified by the command <code class="docutils literal notranslate"><span class="pre">ps</span> <span class="pre">-L</span></code> on Linux, for example), you can call <a class="reference internal" href="QObject.html#PySide2.QtCore.PySide2.QtCore.QObject.setObjectName" title="PySide2.QtCore.PySide2.QtCore.QObject.setObjectName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setObjectName()</span></code></a> before starting the thread. If you don’t call <a class="reference internal" href="QObject.html#PySide2.QtCore.PySide2.QtCore.QObject.setObjectName" title="PySide2.QtCore.PySide2.QtCore.QObject.setObjectName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setObjectName()</span></code></a> , the name given to your thread will be the class name of the runtime type of your thread object (for example, <code class="docutils literal notranslate"><span class="pre">&quot;RenderThread&quot;</span></code> in the case of the <span class="xref std std-ref">Mandelbrot Example</span> , as that is the name of the <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> subclass). Note that this is currently not available with release builds on Windows.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">QThreadStorage</span></code>  <span class="xref std std-ref">Mandelbrot Example</span>  <span class="xref std std-ref">Semaphores Example</span>  <span class="xref std std-ref">Wait Conditions Example</span></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide2.QtCore.QThread">
<em class="property">class </em><code class="sig-name descname">QThread</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">parent=None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.QThread" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param parent</dt>
<dd class="field-odd"><p><a class="reference internal" href="QObject.html#PySide2.QtCore.QObject" title="PySide2.QtCore.QObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">QObject</span></code></a></p>
</dd>
</dl>
</div></blockquote>
<p>Constructs a new <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> to manage a new thread. The <code class="docutils literal notranslate"><span class="pre">parent</span></code> takes ownership of the <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> . The thread does not begin executing until <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="PySide2.QtCore.PySide2.QtCore.QThread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> is called.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="PySide2.QtCore.PySide2.QtCore.QThread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.Priority">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">Priority</code><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.Priority" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum type indicates how the operating system should schedule newly created threads.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QThread.IdlePriority</p></td>
<td><p>scheduled only when no other threads are running.</p></td>
</tr>
<tr class="row-odd"><td><p>QThread.LowestPriority</p></td>
<td><p>scheduled less often than .</p></td>
</tr>
<tr class="row-even"><td><p>QThread.LowPriority</p></td>
<td><p>scheduled less often than .</p></td>
</tr>
<tr class="row-odd"><td><p>QThread.NormalPriority</p></td>
<td><p>the default priority of the operating system.</p></td>
</tr>
<tr class="row-even"><td><p>QThread.HighPriority</p></td>
<td><p>scheduled more often than .</p></td>
</tr>
<tr class="row-odd"><td><p>QThread.HighestPriority</p></td>
<td><p>scheduled more often than .</p></td>
</tr>
<tr class="row-even"><td><p>QThread.TimeCriticalPriority</p></td>
<td><p>scheduled as often as possible.</p></td>
</tr>
<tr class="row-odd"><td><p>QThread.InheritPriority</p></td>
<td><p>use the same priority as the creating thread. This is the default.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.currentThread">
<em class="property">static </em><code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">currentThread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.currentThread" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a></p>
</dd>
</dl>
<p>Returns a pointer to a <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> which manages the currently executing thread.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.eventDispatcher">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">eventDispatcher</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.eventDispatcher" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="QAbstractEventDispatcher.html#PySide2.QtCore.QAbstractEventDispatcher" title="PySide2.QtCore.QAbstractEventDispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractEventDispatcher</span></code></a></p>
</dd>
</dl>
<p>Returns a pointer to the event dispatcher object for the thread. If no event dispatcher exists for the thread, this function returns <code class="docutils literal notranslate"><span class="pre">None</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setEventDispatcher" title="PySide2.QtCore.PySide2.QtCore.QThread.setEventDispatcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setEventDispatcher()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.exec_">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">exec_</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.exec_" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Enters the event loop and waits until <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.exit" title="PySide2.QtCore.PySide2.QtCore.QThread.exit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exit()</span></code></a> is called, returning the value that was passed to <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.exit" title="PySide2.QtCore.PySide2.QtCore.QThread.exit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exit()</span></code></a> . The value returned is 0 if <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.exit" title="PySide2.QtCore.PySide2.QtCore.QThread.exit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exit()</span></code></a> is called via <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.quit" title="PySide2.QtCore.PySide2.QtCore.QThread.quit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quit()</span></code></a> .</p>
<p>This function is meant to be called from within <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> . It is necessary to call this function to start event handling.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.quit" title="PySide2.QtCore.PySide2.QtCore.QThread.quit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quit()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.exit" title="PySide2.QtCore.PySide2.QtCore.QThread.exit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exit()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.exit">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">exit</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">retcode=0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.exit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>retcode</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Tells the thread’s event loop to exit with a return code.</p>
<p>After calling this function, the thread leaves the event loop and returns from the call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec()</span></code> . The <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec()</span></code> function returns <code class="docutils literal notranslate"><span class="pre">returnCode</span></code> .</p>
<p>By convention, a <code class="docutils literal notranslate"><span class="pre">returnCode</span></code> of 0 means success, any non-zero value indicates an error.</p>
<p>Note that unlike the C library function of the same name, this function <em>does</em> return to the caller – it is event processing that stops.</p>
<p>No QEventLoops will be started anymore in this thread until <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec()</span></code> has been called again. If the eventloop in <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec()</span></code> is not running then the next call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec()</span></code> will also return immediately.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.quit" title="PySide2.QtCore.PySide2.QtCore.QThread.quit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quit()</span></code></a>  <a class="reference internal" href="QEventLoop.html#PySide2.QtCore.QEventLoop" title="PySide2.QtCore.QEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">QEventLoop</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.idealThreadCount">
<em class="property">static </em><code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">idealThreadCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.idealThreadCount" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Returns the ideal number of threads that can be run on the system. This is done querying the number of processor cores, both real and logical, in the system. This function returns 1 if the number of processor cores could not be detected.</p>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.isFinished">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">isFinished</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.isFinished" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the thread is finished; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.isRunning" title="PySide2.QtCore.PySide2.QtCore.QThread.isRunning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isRunning()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.isInterruptionRequested">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">isInterruptionRequested</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.isInterruptionRequested" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Return true if the task running on this thread should be stopped. An interruption can be requested by <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.requestInterruption" title="PySide2.QtCore.PySide2.QtCore.QThread.requestInterruption"><code class="xref py py-meth docutils literal notranslate"><span class="pre">requestInterruption()</span></code></a> .</p>
<p>This function can be used to make long running tasks cleanly interruptible. Never checking or acting on the value returned by this function is safe, however it is advisable do so regularly in long running functions. Take care not to call it too often, to keep the overhead low.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">long_task</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">forever</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">QThread</span><span class="p">::</span><span class="n">currentThread</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isInterruptionRequested</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.currentThread" title="PySide2.QtCore.PySide2.QtCore.QThread.currentThread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">currentThread()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.requestInterruption" title="PySide2.QtCore.PySide2.QtCore.QThread.requestInterruption"><code class="xref py py-meth docutils literal notranslate"><span class="pre">requestInterruption()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.isRunning">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">isRunning</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.isRunning" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the thread is running; otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.isFinished" title="PySide2.QtCore.PySide2.QtCore.QThread.isFinished"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isFinished()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.loopLevel">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">loopLevel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.loopLevel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p>Returns the current event loop level for the thread.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This can only be called within the thread itself, i.e. when it is the current thread.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.msleep">
<em class="property">static </em><code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">msleep</code><span class="sig-paren">(</span><em class="sig-param">arg__1</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.msleep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg__1</strong> – long</p>
</dd>
</dl>
<p>Forces the current thread to sleep for <code class="docutils literal notranslate"><span class="pre">msecs</span></code> milliseconds.</p>
<p>Avoid using this function if you need to wait for a given condition to change. Instead, connect a slot to the signal that indicates the change or use an event handler (see <a class="reference internal" href="QObject.html#PySide2.QtCore.PySide2.QtCore.QObject.event" title="PySide2.QtCore.PySide2.QtCore.QObject.event"><code class="xref py py-meth docutils literal notranslate"><span class="pre">event()</span></code></a> ).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function does not guarantee accuracy. The application may sleep longer than <code class="docutils literal notranslate"><span class="pre">msecs</span></code> under heavy load conditions. Some OSes might round <code class="docutils literal notranslate"><span class="pre">msecs</span></code> up to 10 ms or 15 ms.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.sleep" title="PySide2.QtCore.PySide2.QtCore.QThread.sleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sleep()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.usleep" title="PySide2.QtCore.PySide2.QtCore.QThread.usleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">usleep()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.priority">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">priority</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.priority" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.Priority" title="PySide2.QtCore.PySide2.QtCore.QThread.Priority"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Priority</span></code></a></p>
</dd>
</dl>
<p>Returns the priority for a running thread. If the thread is not running, this function returns <code class="docutils literal notranslate"><span class="pre">InheritPriority</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Priority</span></code>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setPriority" title="PySide2.QtCore.PySide2.QtCore.QThread.setPriority"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setPriority()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="PySide2.QtCore.PySide2.QtCore.QThread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.quit">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">quit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.quit" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells the thread’s event loop to exit with return code 0 (success). Equivalent to calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.exit" title="PySide2.QtCore.PySide2.QtCore.QThread.exit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exit</span></code></a> (0).</p>
<p>This function does nothing if the thread does not have an event loop.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.exit" title="PySide2.QtCore.PySide2.QtCore.QThread.exit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exit()</span></code></a>  <a class="reference internal" href="QEventLoop.html#PySide2.QtCore.QEventLoop" title="PySide2.QtCore.QEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">QEventLoop</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.requestInterruption">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">requestInterruption</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.requestInterruption" title="Permalink to this definition">¶</a></dt>
<dd><p>Request the interruption of the thread. That request is advisory and it is up to code running on the thread to decide if and how it should act upon such request. This function does not stop any event loop running on the thread and does not terminate it in any way.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.isInterruptionRequested" title="PySide2.QtCore.PySide2.QtCore.QThread.isInterruptionRequested"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isInterruptionRequested()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.run">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The starting point for the thread. After calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="PySide2.QtCore.PySide2.QtCore.QThread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> , the newly created thread calls this function. The default implementation simply calls <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec()</span></code> .</p>
<p>You can reimplement this function to facilitate advanced thread management. Returning from this method will end the execution of the thread.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="PySide2.QtCore.PySide2.QtCore.QThread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.wait" title="PySide2.QtCore.PySide2.QtCore.QThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.setEventDispatcher">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">setEventDispatcher</code><span class="sig-paren">(</span><em class="sig-param">eventDispatcher</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.setEventDispatcher" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>eventDispatcher</strong> – <a class="reference internal" href="QAbstractEventDispatcher.html#PySide2.QtCore.QAbstractEventDispatcher" title="PySide2.QtCore.QAbstractEventDispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">QAbstractEventDispatcher</span></code></a></p>
</dd>
</dl>
<p>Sets the event dispatcher for the thread to <code class="docutils literal notranslate"><span class="pre">eventDispatcher</span></code> . This is only possible as long as there is no event dispatcher installed for the thread yet. That is, before the thread has been started with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="PySide2.QtCore.PySide2.QtCore.QThread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> or, in case of the main thread, before <a class="reference internal" href="QCoreApplication.html#PySide2.QtCore.QCoreApplication" title="PySide2.QtCore.QCoreApplication"><code class="xref py py-class docutils literal notranslate"><span class="pre">QCoreApplication</span></code></a> has been instantiated. This method takes ownership of the object.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.eventDispatcher" title="PySide2.QtCore.PySide2.QtCore.QThread.eventDispatcher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eventDispatcher()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.setPriority">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">setPriority</code><span class="sig-paren">(</span><em class="sig-param">priority</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.setPriority" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>priority</strong> – <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.Priority" title="PySide2.QtCore.PySide2.QtCore.QThread.Priority"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Priority</span></code></a></p>
</dd>
</dl>
<p>This function sets the <code class="docutils literal notranslate"><span class="pre">priority</span></code> for a running thread. If the thread is not running, this function does nothing and returns immediately. Use <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="PySide2.QtCore.PySide2.QtCore.QThread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> to start a thread with a specific priority.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">priority</span></code> argument can be any value in the <code class="docutils literal notranslate"><span class="pre">QThread::Priority</span></code> enum except for <code class="docutils literal notranslate"><span class="pre">InheritPriorty</span></code> .</p>
<p>The effect of the <code class="docutils literal notranslate"><span class="pre">priority</span></code> parameter is dependent on the operating system’s scheduling policy. In particular, the <code class="docutils literal notranslate"><span class="pre">priority</span></code> will be ignored on systems that do not support thread priorities (such as on Linux, see <a class="reference external" href="http://linux.die.net/man/2/sched_setscheduler">http://linux.die.net/man/2/sched_setscheduler</a> for more details).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">Priority</span></code>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.priority" title="PySide2.QtCore.PySide2.QtCore.QThread.priority"><code class="xref py py-meth docutils literal notranslate"><span class="pre">priority()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="PySide2.QtCore.PySide2.QtCore.QThread.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.setStackSize">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">setStackSize</code><span class="sig-paren">(</span><em class="sig-param">stackSize</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.setStackSize" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>stackSize</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">uint</span></code></p>
</dd>
</dl>
<p>Sets the maximum stack size for the thread to <code class="docutils literal notranslate"><span class="pre">stackSize</span></code> . If <code class="docutils literal notranslate"><span class="pre">stackSize</span></code> is greater than zero, the maximum stack size is set to <code class="docutils literal notranslate"><span class="pre">stackSize</span></code> bytes, otherwise the maximum stack size is automatically determined by the operating system.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Most operating systems place minimum and maximum limits on thread stack sizes. The thread will fail to start if the stack size is outside these limits.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.stackSize" title="PySide2.QtCore.PySide2.QtCore.QThread.stackSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stackSize()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled">
<em class="property">static </em><code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">setTerminationEnabled</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">enabled=true</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>enabled</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Enables or disables termination of the current thread based on the <code class="docutils literal notranslate"><span class="pre">enabled</span></code> parameter. The thread must have been started by <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> .</p>
<p>When <code class="docutils literal notranslate"><span class="pre">enabled</span></code> is false, termination is disabled. Future calls to <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="PySide2.QtCore.PySide2.QtCore.QThread.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> will return immediately without effect. Instead, the termination is deferred until termination is enabled.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">enabled</span></code> is true, termination is enabled. Future calls to <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="PySide2.QtCore.PySide2.QtCore.QThread.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> will terminate the thread normally. If termination has been deferred (i.e. <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="PySide2.QtCore.PySide2.QtCore.QThread.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> was called with termination disabled), this function will terminate the calling thread <em>immediately</em> . Note that this function will not return in this case.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="PySide2.QtCore.PySide2.QtCore.QThread.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.sleep">
<em class="property">static </em><code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">sleep</code><span class="sig-paren">(</span><em class="sig-param">arg__1</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.sleep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg__1</strong> – long</p>
</dd>
</dl>
<p>Forces the current thread to sleep for <code class="docutils literal notranslate"><span class="pre">secs</span></code> seconds.</p>
<p>Avoid using this function if you need to wait for a given condition to change. Instead, connect a slot to the signal that indicates the change or use an event handler (see <a class="reference internal" href="QObject.html#PySide2.QtCore.PySide2.QtCore.QObject.event" title="PySide2.QtCore.PySide2.QtCore.QObject.event"><code class="xref py py-meth docutils literal notranslate"><span class="pre">event()</span></code></a> ).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function does not guarantee accuracy. The application may sleep longer than <code class="docutils literal notranslate"><span class="pre">secs</span></code> under heavy load conditions.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.msleep" title="PySide2.QtCore.PySide2.QtCore.QThread.msleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">msleep()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.usleep" title="PySide2.QtCore.PySide2.QtCore.QThread.usleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">usleep()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.stackSize">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">stackSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.stackSize" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">uint</span></code></p>
</dd>
</dl>
<p>Returns the maximum stack size for the thread (if set with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setStackSize" title="PySide2.QtCore.PySide2.QtCore.QThread.setStackSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setStackSize()</span></code></a> ); otherwise returns zero.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setStackSize" title="PySide2.QtCore.PySide2.QtCore.QThread.setStackSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setStackSize()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.start">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">start</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">priority=InheritPriority</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.start" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>priority</strong> – <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.Priority" title="PySide2.QtCore.PySide2.QtCore.QThread.Priority"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Priority</span></code></a></p>
</dd>
</dl>
<p>Begins execution of the thread by calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> . The operating system will schedule the thread according to the <code class="docutils literal notranslate"><span class="pre">priority</span></code> parameter. If the thread is already running, this function does nothing.</p>
<p>The effect of the <code class="docutils literal notranslate"><span class="pre">priority</span></code> parameter is dependent on the operating system’s scheduling policy. In particular, the <code class="docutils literal notranslate"><span class="pre">priority</span></code> will be ignored on systems that do not support thread priorities (such as on Linux, see the sched_setscheduler documentation for more details).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="PySide2.QtCore.PySide2.QtCore.QThread.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.terminate">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminates the execution of the thread. The thread may or may not be terminated immediately, depending on the operating system’s scheduling policies. Use <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.wait" title="PySide2.QtCore.PySide2.QtCore.QThread.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> after , to be sure.</p>
<p>When the thread is terminated, all threads waiting for the thread to finish will be woken up.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is dangerous and its use is discouraged. The thread can be terminated at any point in its code path. Threads can be terminated while modifying data. There is no chance for the thread to clean up after itself, unlock any held mutexes, etc. In short, use this function only if absolutely necessary.</p>
</div>
<p>Termination can be explicitly enabled or disabled by calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled" title="PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setTerminationEnabled()</span></code></a> . Calling this function while termination is disabled results in the termination being deferred, until termination is re-enabled. See the documentation of <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled" title="PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setTerminationEnabled()</span></code></a> for more information.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled" title="PySide2.QtCore.PySide2.QtCore.QThread.setTerminationEnabled"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setTerminationEnabled()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.usleep">
<em class="property">static </em><code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">usleep</code><span class="sig-paren">(</span><em class="sig-param">arg__1</em><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.usleep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg__1</strong> – long</p>
</dd>
</dl>
<p>Forces the current thread to sleep for <code class="docutils literal notranslate"><span class="pre">usecs</span></code> microseconds.</p>
<p>Avoid using this function if you need to wait for a given condition to change. Instead, connect a slot to the signal that indicates the change or use an event handler (see <a class="reference internal" href="QObject.html#PySide2.QtCore.PySide2.QtCore.QObject.event" title="PySide2.QtCore.PySide2.QtCore.QObject.event"><code class="xref py py-meth docutils literal notranslate"><span class="pre">event()</span></code></a> ).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function does not guarantee accuracy. The application may sleep longer than <code class="docutils literal notranslate"><span class="pre">usecs</span></code> under heavy load conditions. Some OSes might round <code class="docutils literal notranslate"><span class="pre">usecs</span></code> up to 10 ms or 15 ms; on Windows, it will be rounded up to a multiple of 1 ms.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.sleep" title="PySide2.QtCore.PySide2.QtCore.QThread.sleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sleep()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.msleep" title="PySide2.QtCore.PySide2.QtCore.QThread.msleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">msleep()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.wait">
<code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">wait</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">time=ULONG_MAX</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.wait" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time</strong> – long</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Blocks the thread until either of these conditions is met:</p>
<ul class="simple">
<li><p>The thread associated with this <a class="reference internal" href="#PySide2.QtCore.QThread" title="PySide2.QtCore.QThread"><code class="xref py py-class docutils literal notranslate"><span class="pre">QThread</span></code></a> object has finished execution (i.e. when it returns from <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> ). This function will return true if the thread has finished. It also returns true if the thread has not been started yet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code> milliseconds has elapsed. If <code class="docutils literal notranslate"><span class="pre">time</span></code> is ULONG_MAX (the default), then the wait will never timeout (the thread must return from <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.run" title="PySide2.QtCore.PySide2.QtCore.QThread.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> ). This function will return false if the wait timed out.</p></li>
</ul>
<p>This provides similar functionality to the POSIX <code class="docutils literal notranslate"><span class="pre">pthread_join()</span></code> function.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.sleep" title="PySide2.QtCore.PySide2.QtCore.QThread.sleep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sleep()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QThread.terminate" title="PySide2.QtCore.PySide2.QtCore.QThread.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QThread.yieldCurrentThread">
<em class="property">static </em><code class="sig-prename descclassname">PySide2.QtCore.QThread.</code><code class="sig-name descname">yieldCurrentThread</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QThread.yieldCurrentThread" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields execution of the current thread to another runnable thread, if any. Note that the operating system decides to which thread to switch.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2019 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>