
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>QReadWriteLock &#8212; Qt for Python</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <link rel="search" title="Search" href="../../search.html" />
  <link rel="stylesheet" type="text/css" href="/style/pyside.css" />
  <link rel="icon" type="image/png" href="/style/pyside-32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/style/pyside-16px.png" sizes="16x16" />
  <script type="text/javascript"> wpThemeFolder = 'https://qt.io/wp-content/themes/oneqt'; </script>
  <script type="text/javascript" src="/scripts/main.js"></script>
  <script type="text/javascript" src="/scripts/extras.js"></script>
  <script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-54043535-2', 'qt.io');
    ga('set', 'forceSSL', true);
    ga('send', 'pageview');
  </script>

  </head><body>
<div id="container">
    <div class="header">
        <div class="header_container">
            <header id="navbar">
            </header>
        </div>
    </div>
    <div class="main">
        <div class="main-rounded">
            <div class="navigationbar">
                <ul class="sub-navigation">
                    <li><a href="https://wiki.qt.io/">Wiki</a></li>
                    <li><a href="https://doc.qt.io/">Documentation</a></li>
                    <li><a href="https://forum.qt.io/">Forum</a></li>
                    <li><a href="https://bugreports.qt.io/">Bug Reports</a></li>
                    <li><a href="https://codereview.qt-project.org/">Code Review</a></li>
                </ul>
                <div id="main_title_bar"><h1>Qt Documentation</h1></div>
                <div class="related">
                    <ul>
                        
                        <li><a href="../../index.html">Qt for Python 5.13.0</a></li> 
                    </ul>
                </div>
            </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QReadWriteLock</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-PySide2.QtCore"></span><div class="section" id="qreadwritelock">
<span id="id1"></span><h1>QReadWriteLock<a class="headerlink" href="#qreadwritelock" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">QReadWriteLock</span></code></a> class provides read-write locking. <a class="reference internal" href="#more">More</a>…</p>
</div></blockquote>
<div class="graphviz"><img src="../../_images/inheritance-67307691047d87d1b12f3c7e58251bfb7129459e.png" alt="Inheritance diagram of PySide2.QtCore.QReadWriteLock" usemap="#inheritance7be8b6fda9" class="inheritance graphviz" /></div>
<map id="inheritance7be8b6fda9" name="inheritance7be8b6fda9">
<area shape="rect" id="node1" href="#PySide2.QtCore.QReadWriteLock" title="QtCore.QReadWriteLock" alt="" coords="5,5,177,31"/>
</map><div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<div class="function-list docutils container">
<ul class="simple">
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForRead</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForWrite</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tryLockForRead</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tryLockForRead</span></code></a> (timeout)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tryLockForWrite</span></code></a> ()</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tryLockForWrite</span></code></a> (timeout)</p></li>
<li><p>def <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock</span></code></a> ()</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote id="more">
<div><p>A read-write lock is a synchronization tool for protecting resources that can be accessed for reading and writing. This type of lock is useful if you want to allow multiple threads to have simultaneous read-only access, but as soon as one thread wants to write to the resource, all other threads must be blocked until the writing is complete.</p>
<p>In many cases, <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">QReadWriteLock</span></code></a> is a direct competitor to <a class="reference internal" href="QMutex.html#PySide2.QtCore.QMutex" title="PySide2.QtCore.QMutex"><code class="xref py py-class docutils literal notranslate"><span class="pre">QMutex</span></code></a> . <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">QReadWriteLock</span></code></a> is a good choice if there are many concurrent reads and writing occurs infrequently.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">QReadWriteLock</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">ReaderThread</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
        <span class="c1"># ...</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">lockForRead</span><span class="p">()</span>
        <span class="n">read_file</span><span class="p">()</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>
        <span class="c1"># ...</span>

<span class="k">class</span> <span class="nc">WriterThread</span><span class="p">:</span>
    <span class="c1">#...</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
        <span class="c1"># ...</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">lockForWrite</span><span class="p">()</span>
        <span class="n">write_file</span><span class="p">()</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>
        <span class="c1"># ...</span>
</pre></div>
</div>
<p>To ensure that writers aren’t blocked forever by readers, readers attempting to obtain a lock will not succeed if there is a blocked writer waiting for access, even if the lock is currently only accessed by other readers. Also, if the lock is accessed by a writer and another writer comes in, that writer will have priority over any readers that might also be waiting.</p>
<p>Like <a class="reference internal" href="QMutex.html#PySide2.QtCore.QMutex" title="PySide2.QtCore.QMutex"><code class="xref py py-class docutils literal notranslate"><span class="pre">QMutex</span></code></a> , a <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">QReadWriteLock</span></code></a> can be recursively locked by the same thread when constructed with <code class="xref py py-attr docutils literal notranslate"><span class="pre">Recursive</span></code> as <code class="xref py py-attr docutils literal notranslate"><span class="pre">RecursionMode</span></code> . In such cases, <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a> must be called the same number of times <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForWrite()</span></code></a> or <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForRead()</span></code></a> was called. Note that the lock type cannot be changed when trying to lock recursively, i.e. it is not possible to lock for reading in a thread that already has locked for writing (and vice versa).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="QReadLocker.html#PySide2.QtCore.QReadLocker" title="PySide2.QtCore.QReadLocker"><code class="xref py py-class docutils literal notranslate"><span class="pre">QReadLocker</span></code></a>  <a class="reference internal" href="QWriteLocker.html#PySide2.QtCore.QWriteLocker" title="PySide2.QtCore.QWriteLocker"><code class="xref py py-class docutils literal notranslate"><span class="pre">QWriteLocker</span></code></a>  <a class="reference internal" href="QMutex.html#PySide2.QtCore.QMutex" title="PySide2.QtCore.QMutex"><code class="xref py py-class docutils literal notranslate"><span class="pre">QMutex</span></code></a>  <a class="reference internal" href="QSemaphore.html#PySide2.QtCore.QSemaphore" title="PySide2.QtCore.QSemaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">QSemaphore</span></code></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide2.QtCore.QReadWriteLock">
<em class="property">class </em><code class="sig-name descname">QReadWriteLock</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">recursionMode=NonRecursive</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.QReadWriteLock" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param recursionMode</dt>
<dd class="field-odd"><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">RecursionMode</span></code></p>
</dd>
</dl>
</div></blockquote>
<p>Constructs a <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">QReadWriteLock</span></code></a> object in the given <code class="docutils literal notranslate"><span class="pre">recursionMode</span></code> .</p>
<p>The default recursion mode is <code class="xref py py-attr docutils literal notranslate"><span class="pre">NonRecursive</span></code> .</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForWrite()</span></code></a>  <code class="xref py py-attr docutils literal notranslate"><span class="pre">RecursionMode</span></code></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.RecursionMode">
<code class="sig-prename descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="sig-name descname">RecursionMode</code><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.RecursionMode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils align-default">
<colgroup>
<col style="width: 8%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Constant</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QReadWriteLock.Recursive</p></td>
<td><p>In this mode, a thread can lock the same <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">QReadWriteLock</span></code></a> multiple times. The <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">QReadWriteLock</span></code></a> won’t be unlocked until a corresponding number of <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a> calls have been made.</p></td>
</tr>
<tr class="row-odd"><td><p>QReadWriteLock.NonRecursive</p></td>
<td><p>In this mode, a thread may only lock a <a class="reference internal" href="#PySide2.QtCore.QReadWriteLock" title="PySide2.QtCore.QReadWriteLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">QReadWriteLock</span></code></a> once.</p></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">QReadWriteLock()</span></code></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.StateForWaitCondition">
<code class="sig-prename descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="sig-name descname">StateForWaitCondition</code><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.StateForWaitCondition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead">
<code class="sig-prename descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="sig-name descname">lockForRead</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Locks the lock for reading. This function will block the current thread if another thread has locked for writing.</p>
<p>It is not possible to lock for read if the thread already has locked for write.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForWrite()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tryLockForRead()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite">
<code class="sig-prename descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="sig-name descname">lockForWrite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Locks the lock for writing. This function will block the current thread if another thread (including the current) has locked for reading or writing (unless the lock has been created using the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Recursive</span></code> mode).</p>
<p>It is not possible to lock for write if the thread already has locked for read.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tryLockForWrite()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead">
<code class="sig-prename descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="sig-name descname">tryLockForRead</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Attempts to lock for reading. If the lock was obtained, this function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> , otherwise it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> instead of waiting for the lock to become available, i.e. it does not block.</p>
<p>The lock attempt will fail if another thread has locked for writing.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a> before another thread can successfully lock it for writing.</p>
<p>It is not possible to lock for read if the thread already has locked for write.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForRead()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-prename descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="sig-name descname">tryLockForRead</code><span class="sig-paren">(</span><em class="sig-param">timeout</em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeout</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>This is an overloaded function.</p>
<p>Attempts to lock for reading. This function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the lock was obtained; otherwise it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> . If another thread has locked for writing, this function will wait for at most <code class="docutils literal notranslate"><span class="pre">timeout</span></code> milliseconds for the lock to become available.</p>
<p>Note: Passing a negative number as the <code class="docutils literal notranslate"><span class="pre">timeout</span></code> is equivalent to calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForRead()</span></code></a> , i.e. this function will wait forever until lock can be locked for reading when <code class="docutils literal notranslate"><span class="pre">timeout</span></code> is negative.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a> before another thread can successfully lock it for writing.</p>
<p>It is not possible to lock for read if the thread already has locked for write.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForRead()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite">
<code class="sig-prename descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="sig-name descname">tryLockForWrite</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>Attempts to lock for writing. If the lock was obtained, this function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> ; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> immediately.</p>
<p>The lock attempt will fail if another thread has locked for reading or writing.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a> before another thread can successfully lock it.</p>
<p>It is not possible to lock for write if the thread already has locked for read.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForWrite()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-prename descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="sig-name descname">tryLockForWrite</code><span class="sig-paren">(</span><em class="sig-param">timeout</em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timeout</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p>This is an overloaded function.</p>
<p>Attempts to lock for writing. This function returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the lock was obtained; otherwise it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> . If another thread has locked for reading or writing, this function will wait for at most <code class="docutils literal notranslate"><span class="pre">timeout</span></code> milliseconds for the lock to become available.</p>
<p>Note: Passing a negative number as the <code class="docutils literal notranslate"><span class="pre">timeout</span></code> is equivalent to calling <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForWrite()</span></code></a> , i.e. this function will wait forever until lock can be locked for writing when <code class="docutils literal notranslate"><span class="pre">timeout</span></code> is negative.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a> before another thread can successfully lock it.</p>
<p>It is not possible to lock for write if the thread already has locked for read.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForWrite()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock">
<code class="sig-prename descclassname">PySide2.QtCore.QReadWriteLock.</code><code class="sig-name descname">unlock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocks the lock.</p>
<p>Attempting to unlock a lock that is not locked is an error, and will result in program termination.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.lockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lockForWrite()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForRead"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tryLockForRead()</span></code></a>  <a class="reference internal" href="#PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite" title="PySide2.QtCore.PySide2.QtCore.QReadWriteLock.tryLockForWrite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tryLockForWrite()</span></code></a></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <p>© 2019 The Qt Company Ltd. Documentation contributions included herein are the copyrights of their respective owners. The documentation provided herein is licensed under the terms of the <a href="http://www.gnu.org/license/fdl.html">GNU Free Documentation License version 1.3</a> as published by the Free Software Foundation. Qt and respective logos are trademarks of The Qt Company Ltd. in Finland and/or other countries worldwide. All other trademarks are property of their respective owners.</p>
    </div></div>
    <div id="footer" class="footer">
    </div>
</div>
  </body>
</html>